<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TGX: tgx::Renderer3D&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">TGX<span id="projectnumber">&#160;1.0.5</span>
   </div>
   <div id="projectbrief">A tiny 2D/3D graphics library optimized for 32 bits microcontrollers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtgx_1_1_renderer3_d.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtgx_1_1_renderer3_d-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tgx::Renderer3D&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for drawing 3D objects onto a <code><a class="el" href="classtgx_1_1_image.html" title="Image class [MAIN CLASS FOR THE 2D API].">Image</a></code> [<b>MAIN CLASS FOR THE 3D API</b>].  
 <a href="classtgx_1_1_renderer3_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_renderer3_d_8h_source.html">Renderer3D.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71cef7bec13ce66591e48fd0b1e57c11"><td class="memItemLeft" align="right" valign="top">TGX_NOINLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a71cef7bec13ce66591e48fd0b1e57c11">Renderer3D</a> (const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;viewportSize={0, 0}, <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *im=nullptr, ZBUFFER_t *zbuffer=nullptr)</td></tr>
<tr class="memdesc:a71cef7bec13ce66591e48fd0b1e57c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classtgx_1_1_renderer3_d.html#a71cef7bec13ce66591e48fd0b1e57c11">More...</a><br /></td></tr>
<tr class="separator:a71cef7bec13ce66591e48fd0b1e57c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Global settings.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods use to query and set the global parameters of the renderer: viewport size, zbuffer, projection type... </p>
</div></td></tr>
<tr class="memitem:a7222e72a480ce99a8eb3d3df2dfec0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa">setViewportSize</a> (int lx, int ly)</td></tr>
<tr class="memdesc:a7222e72a480ce99a8eb3d3df2dfec0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the viewport.  <a href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa">More...</a><br /></td></tr>
<tr class="separator:a7222e72a480ce99a8eb3d3df2dfec0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1030e0892d613c3406811755bda599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a6f1030e0892d613c3406811755bda599">setViewportSize</a> (const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;viewport_dim)</td></tr>
<tr class="memdesc:a6f1030e0892d613c3406811755bda599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the viewport.  <a href="classtgx_1_1_renderer3_d.html#a6f1030e0892d613c3406811755bda599">More...</a><br /></td></tr>
<tr class="separator:a6f1030e0892d613c3406811755bda599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e31001994fa3444b15e7037a1d5f1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a99e31001994fa3444b15e7037a1d5f1d">setImage</a> (<a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *im)</td></tr>
<tr class="memdesc:a99e31001994fa3444b15e7037a1d5f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image that will be drawn onto.  <a href="classtgx_1_1_renderer3_d.html#a99e31001994fa3444b15e7037a1d5f1d">More...</a><br /></td></tr>
<tr class="separator:a99e31001994fa3444b15e7037a1d5f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1eaf179bc6573ab508ab3a7e38dab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9">setOffset</a> (int ox, int oy)</td></tr>
<tr class="memdesc:afc1eaf179bc6573ab508ab3a7e38dab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset of the image relative to the viewport.  <a href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9">More...</a><br /></td></tr>
<tr class="separator:afc1eaf179bc6573ab508ab3a7e38dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4fa24bc6a4c5235df0ae3e112c48b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#aae4fa24bc6a4c5235df0ae3e112c48b3">setOffset</a> (const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;offset)</td></tr>
<tr class="memdesc:aae4fa24bc6a4c5235df0ae3e112c48b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset of the image relative to the viewport.  <a href="classtgx_1_1_renderer3_d.html#aae4fa24bc6a4c5235df0ae3e112c48b3">More...</a><br /></td></tr>
<tr class="separator:aae4fa24bc6a4c5235df0ae3e112c48b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c31304f8ec4425401629a7846adff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af0c31304f8ec4425401629a7846adff5">setProjectionMatrix</a> (const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;M)</td></tr>
<tr class="memdesc:af0c31304f8ec4425401629a7846adff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix.  <a href="classtgx_1_1_renderer3_d.html#af0c31304f8ec4425401629a7846adff5">More...</a><br /></td></tr>
<tr class="separator:af0c31304f8ec4425401629a7846adff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bce4752b73a38862733b4f2bcb6f04f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a4bce4752b73a38862733b4f2bcb6f04f">getProjectionMatrix</a> () const</td></tr>
<tr class="memdesc:a4bce4752b73a38862733b4f2bcb6f04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current projection matrix.  <a href="classtgx_1_1_renderer3_d.html#a4bce4752b73a38862733b4f2bcb6f04f">More...</a><br /></td></tr>
<tr class="separator:a4bce4752b73a38862733b4f2bcb6f04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7c15aa00b471522a50af525cf41032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#acf7c15aa00b471522a50af525cf41032">useOrthographicProjection</a> ()</td></tr>
<tr class="memdesc:acf7c15aa00b471522a50af525cf41032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set projection mode to orthographic (ie no z-divide).  <a href="classtgx_1_1_renderer3_d.html#acf7c15aa00b471522a50af525cf41032">More...</a><br /></td></tr>
<tr class="separator:acf7c15aa00b471522a50af525cf41032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bff46c6c71c78546267d7b75bb12644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7bff46c6c71c78546267d7b75bb12644">usePerspectiveProjection</a> ()</td></tr>
<tr class="memdesc:a7bff46c6c71c78546267d7b75bb12644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set projection mode to perspective (ie with z-divide).  <a href="classtgx_1_1_renderer3_d.html#a7bff46c6c71c78546267d7b75bb12644">More...</a><br /></td></tr>
<tr class="separator:a7bff46c6c71c78546267d7b75bb12644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9976b53c527e62c95be427620685f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f">setOrtho</a> (float left, float right, float bottom, float top, float zNear, float zFar)</td></tr>
<tr class="memdesc:a8ff9976b53c527e62c95be427620685f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix as an orthographic matrix.  <a href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f">More...</a><br /></td></tr>
<tr class="separator:a8ff9976b53c527e62c95be427620685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae032c0be73580be8e61c53ad42545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545">setFrustum</a> (float left, float right, float bottom, float top, float zNear, float zFar)</td></tr>
<tr class="memdesc:af0ae032c0be73580be8e61c53ad42545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix as a perspective matrix.  <a href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545">More...</a><br /></td></tr>
<tr class="separator:af0ae032c0be73580be8e61c53ad42545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8437622c6b90f9429769504848d22456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456">setPerspective</a> (float fovy, float aspect, float zNear, float zFar)</td></tr>
<tr class="memdesc:a8437622c6b90f9429769504848d22456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix as a perspective matrix.  <a href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456">More...</a><br /></td></tr>
<tr class="separator:a8437622c6b90f9429769504848d22456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fa32770476cd15f717d3f103fd752d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d">setCulling</a> (int w)</td></tr>
<tr class="memdesc:a76fa32770476cd15f717d3f103fd752d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the face culling strategy.  <a href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d">More...</a><br /></td></tr>
<tr class="separator:a76fa32770476cd15f717d3f103fd752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516e700a5470f52cbd9a82dd59f8c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968">setZbuffer</a> (ZBUFFER_t *zbuffer)</td></tr>
<tr class="memdesc:a516e700a5470f52cbd9a82dd59f8c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the z-buffer.  <a href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968">More...</a><br /></td></tr>
<tr class="separator:a516e700a5470f52cbd9a82dd59f8c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad613bdffc57596703abe1a2a47583003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad613bdffc57596703abe1a2a47583003">clearZbuffer</a> ()</td></tr>
<tr class="memdesc:ad613bdffc57596703abe1a2a47583003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the Zbuffer.  <a href="classtgx_1_1_renderer3_d.html#ad613bdffc57596703abe1a2a47583003">More...</a><br /></td></tr>
<tr class="separator:ad613bdffc57596703abe1a2a47583003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2547893a21094d5f23473ca8d3f7ee36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a2547893a21094d5f23473ca8d3f7ee36">setShaders</a> (<a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> shaders)</td></tr>
<tr class="memdesc:a2547893a21094d5f23473ca8d3f7ee36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the shaders to use for subsequent drawing operations.  <a href="classtgx_1_1_renderer3_d.html#a2547893a21094d5f23473ca8d3f7ee36">More...</a><br /></td></tr>
<tr class="separator:a2547893a21094d5f23473ca8d3f7ee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb0863850052e0f5d4c4156cdd5e8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a5eb0863850052e0f5d4c4156cdd5e8b4">setTextureWrappingMode</a> (<a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> wrap_mode)</td></tr>
<tr class="memdesc:a5eb0863850052e0f5d4c4156cdd5e8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrap mode when for texturing.  <a href="classtgx_1_1_renderer3_d.html#a5eb0863850052e0f5d4c4156cdd5e8b4">More...</a><br /></td></tr>
<tr class="separator:a5eb0863850052e0f5d4c4156cdd5e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16b835173d22fc203451cd205cb2d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af16b835173d22fc203451cd205cb2d34">setTextureQuality</a> (<a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> quality)</td></tr>
<tr class="memdesc:af16b835173d22fc203451cd205cb2d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the texturing quality.  <a href="classtgx_1_1_renderer3_d.html#af16b835173d22fc203451cd205cb2d34">More...</a><br /></td></tr>
<tr class="separator:af16b835173d22fc203451cd205cb2d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scene related methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods related to properties specific to the scene: camera position, lightning... </p>
</div></td></tr>
<tr class="memitem:a6cad095ff0d7eefbdb93ac04b6a3efff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff">setViewMatrix</a> (const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;M)</td></tr>
<tr class="memdesc:a6cad095ff0d7eefbdb93ac04b6a3efff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the view transformation matrix.  <a href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff">More...</a><br /></td></tr>
<tr class="separator:a6cad095ff0d7eefbdb93ac04b6a3efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bf226bb8236ad48314bca2bd0f31f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a35bf226bb8236ad48314bca2bd0f31f8">getViewMatrix</a> () const</td></tr>
<tr class="memdesc:a35bf226bb8236ad48314bca2bd0f31f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current view matrix.  <a href="classtgx_1_1_renderer3_d.html#a35bf226bb8236ad48314bca2bd0f31f8">More...</a><br /></td></tr>
<tr class="separator:a35bf226bb8236ad48314bca2bd0f31f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6d8dbf64d64db311eb2854bdf1ceb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#abd6d8dbf64d64db311eb2854bdf1ceb1">setLookAt</a> (float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ)</td></tr>
<tr class="memdesc:abd6d8dbf64d64db311eb2854bdf1ceb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the view matrix so that the camera is looking at a given direction.  <a href="classtgx_1_1_renderer3_d.html#abd6d8dbf64d64db311eb2854bdf1ceb1">More...</a><br /></td></tr>
<tr class="separator:abd6d8dbf64d64db311eb2854bdf1ceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386ac9391f31bdefc331def7359970eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a386ac9391f31bdefc331def7359970eb">setLookAt</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> eye, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> center, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> up)</td></tr>
<tr class="memdesc:a386ac9391f31bdefc331def7359970eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the view matrix so that the camera is looking at a given direction.  <a href="classtgx_1_1_renderer3_d.html#a386ac9391f31bdefc331def7359970eb">More...</a><br /></td></tr>
<tr class="separator:a386ac9391f31bdefc331def7359970eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63284e47ac2f832f122df06bcbd3193a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a63284e47ac2f832f122df06bcbd3193a">worldToNDC</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a63284e47ac2f832f122df06bcbd3193a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from world coordinates to normalized device coordinates (NDC).  <a href="classtgx_1_1_renderer3_d.html#a63284e47ac2f832f122df06bcbd3193a">More...</a><br /></td></tr>
<tr class="separator:a63284e47ac2f832f122df06bcbd3193a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a76c4ce4af7e3c7da2e3a1a7d1d0d4f01">worldToImage</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from world coordinates to the corresponding image pixel.  <a href="classtgx_1_1_renderer3_d.html#a76c4ce4af7e3c7da2e3a1a7d1d0d4f01">More...</a><br /></td></tr>
<tr class="separator:a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594bb296fe042612d4036c04ae1e2d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b">setLightDirection</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;direction)</td></tr>
<tr class="memdesc:a594bb296fe042612d4036c04ae1e2d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the light source direction.  <a href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b">More...</a><br /></td></tr>
<tr class="separator:a594bb296fe042612d4036c04ae1e2d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412610fe5ada143bfcf9cc017bda809d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a412610fe5ada143bfcf9cc017bda809d">setLightAmbiant</a> (const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;color)</td></tr>
<tr class="memdesc:a412610fe5ada143bfcf9cc017bda809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene ambiant light color.  <a href="classtgx_1_1_renderer3_d.html#a412610fe5ada143bfcf9cc017bda809d">More...</a><br /></td></tr>
<tr class="separator:a412610fe5ada143bfcf9cc017bda809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5463cb7ba2f16fa1cf184999acf7f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#aad5463cb7ba2f16fa1cf184999acf7f5">setLightDiffuse</a> (const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;color)</td></tr>
<tr class="memdesc:aad5463cb7ba2f16fa1cf184999acf7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene diffuse light color.  <a href="classtgx_1_1_renderer3_d.html#aad5463cb7ba2f16fa1cf184999acf7f5">More...</a><br /></td></tr>
<tr class="separator:aad5463cb7ba2f16fa1cf184999acf7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae01958e81972d5bdd3392fbe23eda6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#aae01958e81972d5bdd3392fbe23eda6a">setLightSpecular</a> (const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;color)</td></tr>
<tr class="memdesc:aae01958e81972d5bdd3392fbe23eda6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene specular light color.  <a href="classtgx_1_1_renderer3_d.html#aae01958e81972d5bdd3392fbe23eda6a">More...</a><br /></td></tr>
<tr class="separator:aae01958e81972d5bdd3392fbe23eda6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad40825895c5cb3a675fb15c2035d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a5ad40825895c5cb3a675fb15c2035d97">setLight</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> direction, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;ambiantColor, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;diffuseColor, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;specularColor)</td></tr>
<tr class="memdesc:a5ad40825895c5cb3a675fb15c2035d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the lighting parameters of the scene at once.  <a href="classtgx_1_1_renderer3_d.html#a5ad40825895c5cb3a675fb15c2035d97">More...</a><br /></td></tr>
<tr class="separator:a5ad40825895c5cb3a675fb15c2035d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Model related methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods related to properties specific to the model being drawn: position, material properties... </p>
</div></td></tr>
<tr class="memitem:a7ca1f0b53ca7460869fc3031f8422240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7ca1f0b53ca7460869fc3031f8422240">setModelMatrix</a> (const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;M)</td></tr>
<tr class="memdesc:a7ca1f0b53ca7460869fc3031f8422240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the model tranformation matrix.  <a href="classtgx_1_1_renderer3_d.html#a7ca1f0b53ca7460869fc3031f8422240">More...</a><br /></td></tr>
<tr class="separator:a7ca1f0b53ca7460869fc3031f8422240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92666f8cccbb7233cae2fc07322efcc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a92666f8cccbb7233cae2fc07322efcc3">getModelMatrix</a> () const</td></tr>
<tr class="memdesc:a92666f8cccbb7233cae2fc07322efcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model tranformation matrix.  <a href="classtgx_1_1_renderer3_d.html#a92666f8cccbb7233cae2fc07322efcc3">More...</a><br /></td></tr>
<tr class="separator:a92666f8cccbb7233cae2fc07322efcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29025a5ef39eaf15590bdba70b0e4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a29025a5ef39eaf15590bdba70b0e4e9d">setModelPosScaleRot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;center=<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{ 0, 0, 0 }, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;scale=<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>(1, 1, 1), float rot_angle=0, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;rot_dir=<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{ 0, 1, 0 })</td></tr>
<tr class="memdesc:a29025a5ef39eaf15590bdba70b0e4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the model tranformation matrix to move an object to a given a given location, scale and rotation.  <a href="classtgx_1_1_renderer3_d.html#a29025a5ef39eaf15590bdba70b0e4e9d">More...</a><br /></td></tr>
<tr class="separator:a29025a5ef39eaf15590bdba70b0e4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e7d7c90ab94776798b8031a30235f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae5e7d7c90ab94776798b8031a30235f2">modelToNDC</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:ae5e7d7c90ab94776798b8031a30235f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from model coordinates to normalized device coordinates (NDC).  <a href="classtgx_1_1_renderer3_d.html#ae5e7d7c90ab94776798b8031a30235f2">More...</a><br /></td></tr>
<tr class="separator:ae5e7d7c90ab94776798b8031a30235f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bb400f5ad09195a860f6f7ab3db71c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a27bb400f5ad09195a860f6f7ab3db71c">modelToImage</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a27bb400f5ad09195a860f6f7ab3db71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from model coordinates to the corresponding image pixel.  <a href="classtgx_1_1_renderer3_d.html#a27bb400f5ad09195a860f6f7ab3db71c">More...</a><br /></td></tr>
<tr class="separator:a27bb400f5ad09195a860f6f7ab3db71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5452d61ed252f1ccdce87834ffd8491f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f">setMaterialColor</a> (<a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> color)</td></tr>
<tr class="memdesc:a5452d61ed252f1ccdce87834ffd8491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object material color.  <a href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f">More...</a><br /></td></tr>
<tr class="separator:a5452d61ed252f1ccdce87834ffd8491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04afc9a2671e9cea42d62f0cf0c06003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003">setMaterialAmbiantStrength</a> (float strenght=0.1f)</td></tr>
<tr class="memdesc:a04afc9a2671e9cea42d62f0cf0c06003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much the object material reflects the ambient light.  <a href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003">More...</a><br /></td></tr>
<tr class="separator:a04afc9a2671e9cea42d62f0cf0c06003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b59fb15f8464b2dbc690cf9244648c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c">setMaterialDiffuseStrength</a> (float strenght=0.6f)</td></tr>
<tr class="memdesc:a24b59fb15f8464b2dbc690cf9244648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much the object material reflects the diffuse light.  <a href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c">More...</a><br /></td></tr>
<tr class="separator:a24b59fb15f8464b2dbc690cf9244648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20831a50013228afa468783499f44893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893">setMaterialSpecularStrength</a> (float strenght=0.5f)</td></tr>
<tr class="memdesc:a20831a50013228afa468783499f44893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much the object material reflects the specular light.  <a href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893">More...</a><br /></td></tr>
<tr class="separator:a20831a50013228afa468783499f44893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4d3e69db91b78e7b86cfa8a239e54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e">setMaterialSpecularExponent</a> (int exponent=16)</td></tr>
<tr class="memdesc:a0c4d3e69db91b78e7b86cfa8a239e54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object specular exponent.  <a href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e">More...</a><br /></td></tr>
<tr class="separator:a0c4d3e69db91b78e7b86cfa8a239e54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2f4be4d9c231fdd4f8f624a80a4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8">setMaterial</a> (<a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> color, float ambiantStrength, float diffuseStrength, float specularStrength, int specularExponent)</td></tr>
<tr class="memdesc:a5ae2f4be4d9c231fdd4f8f624a80a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the object material properties at once.  <a href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8">More...</a><br /></td></tr>
<tr class="separator:a5ae2f4be4d9c231fdd4f8f624a80a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing solid geometric primitives.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods for drawing meshes, triangles and quads.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ol type="1">
<li>Normal vector are mandatory when using Gouraud shadding and must be normalized (unit lenght).</li>
<li>Texture dimension must be power of two when using flag <code>SHADER_TEXTURE_WRAP_POW2</code>. <br  />
</li>
<li>Triangle and quads must be given in the correct winding order. The 4 vertices of a quads must be co-planar. <br  />
</li>
<li>The fastest method to display 'static' geometry is to use the <a class="el" href="classtgx_1_1_renderer3_d.html#a0298855a66fc0063e3c935dabac4c51e" title="Draw a Mesh3D object.">drawMesh()</a> method. Other methods are slower and should be reserved for 'dynamic' geometry. <br  />
</li>
<li>Do not forget to clear the z-buffer with <code><a class="el" href="classtgx_1_1_renderer3_d.html#ad613bdffc57596703abe1a2a47583003" title="Clear the Zbuffer.">clearZbuffer()</a></code> at the beggining of each new frame. </li>
</ol>
</dd></dl>
</div></td></tr>
<tr class="memitem:a0298855a66fc0063e3c935dabac4c51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0298855a66fc0063e3c935dabac4c51e">drawMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool use_mesh_material=true, bool draw_chained_meshes=true)</td></tr>
<tr class="memdesc:a0298855a66fc0063e3c935dabac4c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a <a class="el" href="structtgx_1_1_mesh3_d.html" title="3D mesh data stucture.">Mesh3D</a> object.  <a href="classtgx_1_1_renderer3_d.html#a0298855a66fc0063e3c935dabac4c51e">More...</a><br /></td></tr>
<tr class="separator:a0298855a66fc0063e3c935dabac4c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c1eab35027a61fee8a22c68ea348d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad08c1eab35027a61fee8a22c68ea348d">drawTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T1=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T2=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T3=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture=nullptr)</td></tr>
<tr class="memdesc:ad08c1eab35027a61fee8a22c68ea348d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single triangle.  <a href="classtgx_1_1_renderer3_d.html#ad08c1eab35027a61fee8a22c68ea348d">More...</a><br /></td></tr>
<tr class="separator:ad08c1eab35027a61fee8a22c68ea348d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb17f3177a24fbeccbb0d8a801aef88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7bb17f3177a24fbeccbb0d8a801aef88">drawTriangleWithVertexColor</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col1, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col2, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr)</td></tr>
<tr class="memdesc:a7bb17f3177a24fbeccbb0d8a801aef88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single triangle with a given colors on each of its vertices.  <a href="classtgx_1_1_renderer3_d.html#a7bb17f3177a24fbeccbb0d8a801aef88">More...</a><br /></td></tr>
<tr class="separator:a7bb17f3177a24fbeccbb0d8a801aef88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54f3bb4aedeeee2efbb8aa9956bf17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad54f3bb4aedeeee2efbb8aa9956bf17a">drawTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, const uint16_t *ind_normals=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *normals=nullptr, const uint16_t *ind_texture=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *textures=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_image=nullptr)</td></tr>
<tr class="memdesc:ad54f3bb4aedeeee2efbb8aa9956bf17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of triangles.  <a href="classtgx_1_1_renderer3_d.html#ad54f3bb4aedeeee2efbb8aa9956bf17a">More...</a><br /></td></tr>
<tr class="separator:ad54f3bb4aedeeee2efbb8aa9956bf17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1acda7d8cb5a16666acdb3306dcdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afc1acda7d8cb5a16666acdb3306dcdd3">drawQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N4=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T1=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T2=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T3=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T4=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture=nullptr)</td></tr>
<tr class="memdesc:afc1acda7d8cb5a16666acdb3306dcdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single quad.  <a href="classtgx_1_1_renderer3_d.html#afc1acda7d8cb5a16666acdb3306dcdd3">More...</a><br /></td></tr>
<tr class="separator:afc1acda7d8cb5a16666acdb3306dcdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addff7a6a3a439659704d29b524b7f6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#addff7a6a3a439659704d29b524b7f6b2">drawQuadWithVertexColor</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col1, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col2, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col3, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col4, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N4=nullptr)</td></tr>
<tr class="memdesc:addff7a6a3a439659704d29b524b7f6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single quad with a given colors on each of its four vertices.  <a href="classtgx_1_1_renderer3_d.html#addff7a6a3a439659704d29b524b7f6b2">More...</a><br /></td></tr>
<tr class="separator:addff7a6a3a439659704d29b524b7f6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fe01f23d0925292db43938f164d5ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a01fe01f23d0925292db43938f164d5ad">drawQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, const uint16_t *ind_normals=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *normals=nullptr, const uint16_t *ind_texture=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *textures=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_image=nullptr)</td></tr>
<tr class="memdesc:a01fe01f23d0925292db43938f164d5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of quads.  <a href="classtgx_1_1_renderer3_d.html#a01fe01f23d0925292db43938f164d5ad">More...</a><br /></td></tr>
<tr class="separator:a01fe01f23d0925292db43938f164d5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing solid basic shapes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods for drawing cube and spheres. </p>
</div></td></tr>
<tr class="memitem:a44f87bfade3e549ef8b3ec2468705e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a44f87bfade3e549ef8b3ec2468705e77">drawCube</a> ()</td></tr>
<tr class="memdesc:a44f87bfade3e549ef8b3ec2468705e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the unit cube <code>[-1,1]^3</code> in model space.  <a href="classtgx_1_1_renderer3_d.html#a44f87bfade3e549ef8b3ec2468705e77">More...</a><br /></td></tr>
<tr class="separator:a44f87bfade3e549ef8b3ec2468705e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32f027d40abe77c230d9975482d6488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ab32f027d40abe77c230d9975482d6488">drawCube</a> (const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_front_ABCD[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_front, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_back_EFGH[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_back, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_top_HADE[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_top, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_bottom_BGFC[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_bottom, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_left_HGBA[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_left, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_right_DCFE[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_right)</td></tr>
<tr class="memdesc:ab32f027d40abe77c230d9975482d6488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a textured unit cube <code>[-1,1]^3</code> in model space.  <a href="classtgx_1_1_renderer3_d.html#ab32f027d40abe77c230d9975482d6488">More...</a><br /></td></tr>
<tr class="separator:ab32f027d40abe77c230d9975482d6488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b0d511a4144826084788e5f69911a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a2f4b0d511a4144826084788e5f69911a">drawCube</a> (const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_front, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_back, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_top, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_bottom, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_left, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_right)</td></tr>
<tr class="memdesc:a2f4b0d511a4144826084788e5f69911a"><td class="mdescLeft">&#160;</td><td class="mdescRight">draw a textured unit cube [-1,1]^3 (in model space)  <a href="classtgx_1_1_renderer3_d.html#a2f4b0d511a4144826084788e5f69911a">More...</a><br /></td></tr>
<tr class="separator:a2f4b0d511a4144826084788e5f69911a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0737d0bed8e991bdda9c956e6842478d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0737d0bed8e991bdda9c956e6842478d">drawSphere</a> (int nb_sectors, int nb_stacks)</td></tr>
<tr class="memdesc:a0737d0bed8e991bdda9c956e6842478d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a unit radius sphere centered at the origin <code>S(0,1)</code> in model space.  <a href="classtgx_1_1_renderer3_d.html#a0737d0bed8e991bdda9c956e6842478d">More...</a><br /></td></tr>
<tr class="separator:a0737d0bed8e991bdda9c956e6842478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fbb721753ca5a7f0f5237eb2ebbe01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae6fbb721753ca5a7f0f5237eb2ebbe01">drawSphere</a> (int nb_sectors, int nb_stacks, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture)</td></tr>
<tr class="memdesc:ae6fbb721753ca5a7f0f5237eb2ebbe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a textured unit radius sphere centered at the origin S(0,1) in model space.  <a href="classtgx_1_1_renderer3_d.html#ae6fbb721753ca5a7f0f5237eb2ebbe01">More...</a><br /></td></tr>
<tr class="separator:ae6fbb721753ca5a7f0f5237eb2ebbe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c59fee77ca3d42b19d62e9eade1203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a00c59fee77ca3d42b19d62e9eade1203">drawAdaptativeSphere</a> (float quality=1.0f)</td></tr>
<tr class="memdesc:a00c59fee77ca3d42b19d62e9eade1203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a unit radius sphere centered at the origin S(0,1) in model space.  <a href="classtgx_1_1_renderer3_d.html#a00c59fee77ca3d42b19d62e9eade1203">More...</a><br /></td></tr>
<tr class="separator:a00c59fee77ca3d42b19d62e9eade1203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9186b507df18e0df32976781d48909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afa9186b507df18e0df32976781d48909">drawAdaptativeSphere</a> (const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture, float quality=1.0f)</td></tr>
<tr class="memdesc:afa9186b507df18e0df32976781d48909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a textured unit radius sphere centered at the origin S(0,1) in model space.  <a href="classtgx_1_1_renderer3_d.html#afa9186b507df18e0df32976781d48909">More...</a><br /></td></tr>
<tr class="separator:afa9186b507df18e0df32976781d48909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing wireframe geometric primitives.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods for drawing wireframe meshes, triangles and quads.</p>
<p >Two versions for each method :</p><ol type="1">
<li>Fast but low quality drawing.</li>
<li>Slow but high quality drawing (adjustable thickness, alpha-blending, anti-aliasing). <br  />
</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>Wireframe methods do not take the scene lightning into account. </dd></dl>
</div></td></tr>
<tr class="memitem:ae167aca012374ff0ebd009ca3a008df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae167aca012374ff0ebd009ca3a008df9">drawWireFrameMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool draw_chained_meshes=true)</td></tr>
<tr class="memdesc:ae167aca012374ff0ebd009ca3a008df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a mesh in wireframe [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#ae167aca012374ff0ebd009ca3a008df9">More...</a><br /></td></tr>
<tr class="separator:ae167aca012374ff0ebd009ca3a008df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b34fbcf5759c1231f31a16e98ed667e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a3b34fbcf5759c1231f31a16e98ed667e">drawWireFrameMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool draw_chained_meshes, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a3b34fbcf5759c1231f31a16e98ed667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a mesh in wireframe [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a3b34fbcf5759c1231f31a16e98ed667e">More...</a><br /></td></tr>
<tr class="separator:a3b34fbcf5759c1231f31a16e98ed667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021ab6984464a4d7afe933d81bc5ef96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a021ab6984464a4d7afe933d81bc5ef96">drawWireFrameLine</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2)</td></tr>
<tr class="memdesc:a021ab6984464a4d7afe933d81bc5ef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe line segment [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a021ab6984464a4d7afe933d81bc5ef96">More...</a><br /></td></tr>
<tr class="separator:a021ab6984464a4d7afe933d81bc5ef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb9598771b00af5e8aac070b4393231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#addb9598771b00af5e8aac070b4393231">drawWireFrameLine</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:addb9598771b00af5e8aac070b4393231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe line segment [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#addb9598771b00af5e8aac070b4393231">More...</a><br /></td></tr>
<tr class="separator:addb9598771b00af5e8aac070b4393231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8a63bd23b32cf1887940b92a352f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a4c8a63bd23b32cf1887940b92a352f08">drawWireFrameLines</a> (int nb_lines, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices)</td></tr>
<tr class="memdesc:a4c8a63bd23b32cf1887940b92a352f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of wireframe line segments [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a4c8a63bd23b32cf1887940b92a352f08">More...</a><br /></td></tr>
<tr class="separator:a4c8a63bd23b32cf1887940b92a352f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974433794ae62149a59273afbc50ed6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a974433794ae62149a59273afbc50ed6e">drawWireFrameLines</a> (int nb_lines, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a974433794ae62149a59273afbc50ed6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of wireframe line segments [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a974433794ae62149a59273afbc50ed6e">More...</a><br /></td></tr>
<tr class="separator:a974433794ae62149a59273afbc50ed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12199857bf19951674f542a578642aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a12199857bf19951674f542a578642aa2">drawWireFrameTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3)</td></tr>
<tr class="memdesc:a12199857bf19951674f542a578642aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe triangle [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a12199857bf19951674f542a578642aa2">More...</a><br /></td></tr>
<tr class="separator:a12199857bf19951674f542a578642aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6d9c3a846123139123791d3f416be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7e6d9c3a846123139123791d3f416be5">drawWireFrameTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a7e6d9c3a846123139123791d3f416be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe triangle [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a7e6d9c3a846123139123791d3f416be5">More...</a><br /></td></tr>
<tr class="separator:a7e6d9c3a846123139123791d3f416be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdfc3d33a5d201fd7bf8cd66d6b6e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afbdfc3d33a5d201fd7bf8cd66d6b6e4c">drawWireFrameTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices)</td></tr>
<tr class="memdesc:afbdfc3d33a5d201fd7bf8cd66d6b6e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of wireframe triangles [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#afbdfc3d33a5d201fd7bf8cd66d6b6e4c">More...</a><br /></td></tr>
<tr class="separator:afbdfc3d33a5d201fd7bf8cd66d6b6e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eacbe59b3e28b1991d4d35992db563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae5eacbe59b3e28b1991d4d35992db563">drawWireFrameTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:ae5eacbe59b3e28b1991d4d35992db563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of wireframe triangles [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#ae5eacbe59b3e28b1991d4d35992db563">More...</a><br /></td></tr>
<tr class="separator:ae5eacbe59b3e28b1991d4d35992db563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2543a39299d841a368ca5365d90a06c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a2543a39299d841a368ca5365d90a06c0">drawWireFrameQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4)</td></tr>
<tr class="memdesc:a2543a39299d841a368ca5365d90a06c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe quad [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a2543a39299d841a368ca5365d90a06c0">More...</a><br /></td></tr>
<tr class="separator:a2543a39299d841a368ca5365d90a06c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb256562836cddea025867ce83e836e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#abb256562836cddea025867ce83e836e5">drawWireFrameQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:abb256562836cddea025867ce83e836e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe quad [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#abb256562836cddea025867ce83e836e5">More...</a><br /></td></tr>
<tr class="separator:abb256562836cddea025867ce83e836e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb11a254d95e6bcd239026f61cc83dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a3bb11a254d95e6bcd239026f61cc83dc">drawWireFrameQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices)</td></tr>
<tr class="memdesc:a3bb11a254d95e6bcd239026f61cc83dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of wireframe quads [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a3bb11a254d95e6bcd239026f61cc83dc">More...</a><br /></td></tr>
<tr class="separator:a3bb11a254d95e6bcd239026f61cc83dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845bbd628cfd96f379f3f23d880aa60a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a845bbd628cfd96f379f3f23d880aa60a">drawWireFrameQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a845bbd628cfd96f379f3f23d880aa60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a collection of wireframe quads [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a845bbd628cfd96f379f3f23d880aa60a">More...</a><br /></td></tr>
<tr class="separator:a845bbd628cfd96f379f3f23d880aa60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing basic shapes in wireframe.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods for drawing wireframe cubes and spheres.</p>
<p >Two versions for each method :</p><ol type="1">
<li>Fast but low quality drawing. <br  />
</li>
<li>Slow but high quality drawin (adjustable thickness, alpha-blending, anti-aliasing). <br  />
</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>Wireframe methods do not take the scene lightning into account. </dd></dl>
</div></td></tr>
<tr class="memitem:a1522a8010525348deefbfe92b8a9fe53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a1522a8010525348deefbfe92b8a9fe53">drawWireFrameCube</a> ()</td></tr>
<tr class="memdesc:a1522a8010525348deefbfe92b8a9fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the wireframe cube [0,1]^3 (in model space) [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a1522a8010525348deefbfe92b8a9fe53">More...</a><br /></td></tr>
<tr class="separator:a1522a8010525348deefbfe92b8a9fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbdcd49776f2d634a45138c3e8d4f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afcbdcd49776f2d634a45138c3e8d4f82">drawWireFrameCube</a> (float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:afcbdcd49776f2d634a45138c3e8d4f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the wireframe cube [0,1]^3 (in model space) [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#afcbdcd49776f2d634a45138c3e8d4f82">More...</a><br /></td></tr>
<tr class="separator:afcbdcd49776f2d634a45138c3e8d4f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeadf985edca06331aabd301d45a4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afaeadf985edca06331aabd301d45a4ad">drawWireFrameSphere</a> (int nb_sectors, int nb_stacks)</td></tr>
<tr class="memdesc:afaeadf985edca06331aabd301d45a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#afaeadf985edca06331aabd301d45a4ad">More...</a><br /></td></tr>
<tr class="separator:afaeadf985edca06331aabd301d45a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497e0c79f349463357371f8502b6b9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a497e0c79f349463357371f8502b6b9be">drawWireFrameSphere</a> (int nb_sectors, int nb_stacks, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a497e0c79f349463357371f8502b6b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a497e0c79f349463357371f8502b6b9be">More...</a><br /></td></tr>
<tr class="separator:a497e0c79f349463357371f8502b6b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cd871e326daaeb9e26a85ec7bf2de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a43cd871e326daaeb9e26a85ec7bf2de6">drawWireFrameAdaptativeSphere</a> (float quality=1.0f)</td></tr>
<tr class="memdesc:a43cd871e326daaeb9e26a85ec7bf2de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>low quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a43cd871e326daaeb9e26a85ec7bf2de6">More...</a><br /></td></tr>
<tr class="separator:a43cd871e326daaeb9e26a85ec7bf2de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e14dda511fab4edf94bc63096379c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a07e14dda511fab4edf94bc63096379c3">drawWireFrameAdaptativeSphere</a> (float quality, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a07e14dda511fab4edf94bc63096379c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>high quality</em>].  <a href="classtgx_1_1_renderer3_d.html#a07e14dda511fab4edf94bc63096379c3">More...</a><br /></td></tr>
<tr class="separator:a07e14dda511fab4edf94bc63096379c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Drawing 3D point clouds</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Methods for drawing pixels and dots.</p>
<dl class="section remark"><dt>Remarks</dt><dd>the methods do not take the scene lightning into account. </dd></dl>
</div></td></tr>
<tr class="memitem:a8bf2c28c514af367fd47964577f1584d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a8bf2c28c514af367fd47964577f1584d">drawPixel</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos)</td></tr>
<tr class="memdesc:a8bf2c28c514af367fd47964577f1584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel at a given position in model space.  <a href="classtgx_1_1_renderer3_d.html#a8bf2c28c514af367fd47964577f1584d">More...</a><br /></td></tr>
<tr class="separator:a8bf2c28c514af367fd47964577f1584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b04bab823ad980ae1680895f4ef66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a9c7b04bab823ad980ae1680895f4ef66">drawPixel</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, color_t color, float opacity)</td></tr>
<tr class="memdesc:a9c7b04bab823ad980ae1680895f4ef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel at a given position in model space.  <a href="classtgx_1_1_renderer3_d.html#a9c7b04bab823ad980ae1680895f4ef66">More...</a><br /></td></tr>
<tr class="separator:a9c7b04bab823ad980ae1680895f4ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c10061203e26574e147aef75dcd2969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a9c10061203e26574e147aef75dcd2969">drawPixels</a> (int nb_pixels, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list)</td></tr>
<tr class="memdesc:a9c10061203e26574e147aef75dcd2969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of pixels at given positions in model space.  <a href="classtgx_1_1_renderer3_d.html#a9c10061203e26574e147aef75dcd2969">More...</a><br /></td></tr>
<tr class="separator:a9c10061203e26574e147aef75dcd2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cc940d37989db78a9cdaf790000fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af3cc940d37989db78a9cdaf790000fb6">drawPixels</a> (int nb_pixels, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *colors_ind, const color_t *colors, const int *opacities_ind, const float *opacities)</td></tr>
<tr class="memdesc:af3cc940d37989db78a9cdaf790000fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of pixels at given positions in model space with different colors and opacities.  <a href="classtgx_1_1_renderer3_d.html#af3cc940d37989db78a9cdaf790000fb6">More...</a><br /></td></tr>
<tr class="separator:af3cc940d37989db78a9cdaf790000fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae965bedf9a2eb21f8a5cc7c2f389f367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae965bedf9a2eb21f8a5cc7c2f389f367">drawDot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, int r)</td></tr>
<tr class="memdesc:ae965bedf9a2eb21f8a5cc7c2f389f367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a dot/circle at a given position in model space.  <a href="classtgx_1_1_renderer3_d.html#ae965bedf9a2eb21f8a5cc7c2f389f367">More...</a><br /></td></tr>
<tr class="separator:ae965bedf9a2eb21f8a5cc7c2f389f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0459fa6b84613036c70e17fd7d944d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0459fa6b84613036c70e17fd7d944d49">drawDot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, int r, color_t color, float opacity)</td></tr>
<tr class="memdesc:a0459fa6b84613036c70e17fd7d944d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a dot/circle at a given position in model space.  <a href="classtgx_1_1_renderer3_d.html#a0459fa6b84613036c70e17fd7d944d49">More...</a><br /></td></tr>
<tr class="separator:a0459fa6b84613036c70e17fd7d944d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b7d7ad47a01a821532719998c3fda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a616b7d7ad47a01a821532719998c3fda">drawDots</a> (int nb_dots, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int radius)</td></tr>
<tr class="memdesc:a616b7d7ad47a01a821532719998c3fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of dots/circles at given positions in model space.  <a href="classtgx_1_1_renderer3_d.html#a616b7d7ad47a01a821532719998c3fda">More...</a><br /></td></tr>
<tr class="separator:a616b7d7ad47a01a821532719998c3fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ddcca2d8bb674777bff0ba74e314b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a31ddcca2d8bb674777bff0ba74e314b2">drawDots</a> (int nb_dots, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *radius_ind, const int *radius, const int *colors_ind, const color_t *colors, const int *opacities_ind, const float *opacities)</td></tr>
<tr class="memdesc:a31ddcca2d8bb674777bff0ba74e314b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of dots/circles at given positions in model space.  <a href="classtgx_1_1_renderer3_d.html#a31ddcca2d8bb674777bff0ba74e314b2">More...</a><br /></td></tr>
<tr class="separator:a31ddcca2d8bb674777bff0ba74e314b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename color_t, <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t = float&gt;<br />
class tgx::Renderer3D&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;</div><p >Class for drawing 3D objects onto a <code><a class="el" href="classtgx_1_1_image.html" title="Image class [MAIN CLASS FOR THE 2D API].">Image</a></code> [<b>MAIN CLASS FOR THE 3D API</b>]. </p>
<p >A <a class="el" href="classtgx_1_1_renderer3_d.html" title="Class for drawing 3D objects onto a Image [MAIN CLASS FOR THE 3D API].">Renderer3D</a> objects creates a "virtual viewport" and provides a set of methods to manage a scene and draw 3D primitives onto this viewport which is then mapped to a <code><a class="el" href="classtgx_1_1_image.html" title="Image class [MAIN CLASS FOR THE 2D API].">tgx::Image</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LOADED_SHADERS</td><td>list of all shaders that may be used. By default, all shaders are enabled but if is possible to select only a subset of shaders to improve rendering speed and decrease memory usage significantly. Must a <code>|</code> combination of the following flags:<ul>
<li><code>SHADER_PERSPECTIVE</code>: enable perspective projection</li>
<li><code>SHADER_ORTHO</code>: enable orthographic projection</li>
<li><code>SHADER_NOZBUFFER</code>: enable rendering without using a z-buffer</li>
<li><code>SHADER_ZBUFFER</code>: enable rendering with a z-buffer</li>
<li><code>SHADER_FLAT</code>: enable flat shading</li>
<li><code>SHADER_GOURAUD</code>: enable gouraud shading</li>
<li><code>SHADER_NOTEXTURE</code>: enable rendering without texturing</li>
<li><code>SHADER_TEXTURE_NEAREST</code>: enable rendering with texturing using point sampling</li>
<li><code>SHADER_TEXTURE_BILINEAR</code>: enable rendering with texturing using bilinear sampling</li>
<li><code>SHADER_TEXTURE_WRAP_POW2</code>: texture can use 'wrap around' mode with dimensions of texture being power of two.</li>
<li><code>SHADER_TEXTURE_CLAMP</code>: texture can use 'clamping to edge' mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">ZBUFFER_t</td><td>: Type used for storing z-buffer values. Must be either <code>float</code> or <code>uint16_t</code>. The z-buffer must be as large as the image (but can be smaller than the viewport when using an offset).<ul>
<li><code>float</code>: higher quality but requires 4 bytes per pixel.</li>
<li><code>uint16_t</code> : lower quality (z-fighting may occur) but only 2 bytes per pixel. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<ol type="1">
<li>If a drawing call is made that requires a shader that was not enabled in the template parameter <code>LOADED_SHADERS</code> or if the <a class="el" href="classtgx_1_1_renderer3_d.html" title="Class for drawing 3D objects onto a Image [MAIN CLASS FOR THE 3D API].">Renderer3D</a> object state is not valid (e.g. incorrect image size, enabled but missing z-buffer...) then the operation will fails silently. In particular, if drawing without a Z-buffer is performed, the flag <code>SHADER_NOZBUFFER</code> <b>must</b> be set in LOADED_SHADERS. Similarly, if drawing without texturing is performed, the flag <code>SHADER_NOTEXTURE</code> <b>must</b> be set in LOADED_SHADERS.</li>
<li>Z-buffer testing is enabled as soon as a valid z-buffer is provided (with <code><a class="el" href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968" title="Set the z-buffer.">Renderer3D::setZbuffer()</a></code>). Do not forget to erase the z-buffer with <code><a class="el" href="classtgx_1_1_renderer3_d.html#ad613bdffc57596703abe1a2a47583003" title="Clear the Zbuffer.">Renderer3D::clearZbuffer()</a></code> at the start of a new frame.</li>
<li>Normal vectors are mandatory when using Gouraud shading and must always be normalized (unit lenght) !</li>
<li>Texture dimensions must be powers of two when flag <code>SHADER_TEXTURE_WRAP_POW2</code> is set.</li>
<li>Back-face culling is set with <code><a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d" title="Set the face culling strategy.">Renderer3D::setCulling()</a></code>. Triangles and quads must then be provided in the choosen winding order.</li>
<li>It is more efficient to use methods that draws several primitives at once rather than issuing multiple commands for drawing triangle/quads. For static geometry, <code><a class="el" href="classtgx_1_1_renderer3_d.html#a0298855a66fc0063e3c935dabac4c51e" title="Draw a Mesh3D object.">Renderer3D::drawMesh()</a></code> should be use whenever possible insteaed of <code><a class="el" href="classtgx_1_1_renderer3_d.html#a01fe01f23d0925292db43938f164d5ad" title="Draw a collection of quads.">Renderer3D::drawQuads()</a></code>, <code><a class="el" href="classtgx_1_1_renderer3_d.html#ad54f3bb4aedeeee2efbb8aa9956bf17a" title="Draw a collection of triangles.">Renderer3D::drawTriangles()</a></code>...</li>
<li>Wireframe drawing with 'high quality' is (currently) very slow. Use 'low quality' drawing if speed is required. <br  />
 </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a71cef7bec13ce66591e48fd0b1e57c11" name="a71cef7bec13ce66591e48fd0b1e57c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cef7bec13ce66591e48fd0b1e57c11">&#9670;&#160;</a></span>Renderer3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TGX_NOINLINE <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::Renderer3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>viewportSize</em> = <code>{0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>im</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZBUFFER_t *&#160;</td>
          <td class="paramname"><em>zbuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p >Some parameters may be set right way (but they may be also set independantly later).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewportSize</td><td>(Optional) Size of the viewport. See <code><a class="el" href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa" title="Set the size of the viewport.">setViewportSize()</a></code>. </td></tr>
    <tr><td class="paramname">im</td><td>(Optional) the destination image. See <code><a class="el" href="classtgx_1_1_renderer3_d.html#a99e31001994fa3444b15e7037a1d5f1d" title="Set the image that will be drawn onto.">setImage()</a></code>. </td></tr>
    <tr><td class="paramname">zbuffer</td><td>(Optional) the Z-buffer. See <code><a class="el" href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968" title="Set the z-buffer.">setZbuffer()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7222e72a480ce99a8eb3d3df2dfec0aa" name="a7222e72a480ce99a8eb3d3df2dfec0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7222e72a480ce99a8eb3d3df2dfec0aa">&#9670;&#160;</a></span>setViewportSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setViewportSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the size of the viewport. </p>
<p >The normalized coordinates in <code>[-1,1]x[-1,1]</code> are mapped to <code>[0,lx-1]x[0,ly-1]</code> just before rasterization.</p>
<p >It is possible to use a viewport larger than the image drawn onto by using an offset for the image inside the viewport in order to perform 'tile rendering'. see <code><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9" title="Set the offset of the image relative to the viewport.">setOffset()</a></code>.</p>
<p >the maximum viewport size depends on <code>TGX_RASTERIZE_SUBPIXEL_BITS</code> which specifies the sub-pixel precision value used by the 3D rasterizer:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">subpixel bits   </th><th class="markdownTableHeadNone">max viewport size LX*LY    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">2048 x 2048    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">4096 x 4096    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">8192 x 8192    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">16384 x 16384   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lx,ly</td><td>The viewport size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f1030e0892d613c3406811755bda599" name="a6f1030e0892d613c3406811755bda599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1030e0892d613c3406811755bda599">&#9670;&#160;</a></span>setViewportSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setViewportSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport_dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the size of the viewport. </p>
<p >Same as <code><a class="el" href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa" title="Set the size of the viewport.">setViewportSize(int lx, int ly)</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport_dim</td><td>The viewport size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99e31001994fa3444b15e7037a1d5f1d" name="a99e31001994fa3444b15e7037a1d5f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e31001994fa3444b15e7037a1d5f1d">&#9670;&#160;</a></span>setImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the image that will be drawn onto. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The image can be smaller than the viewport. In this case, use <code><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9" title="Set the offset of the image relative to the viewport.">setOffset()</a></code> to select the portion of the viewport that will be drawn.</li>
<li>Passing <code>nullptr</code> remove the current image (and disables all drawing operation <br  />
 until a new image is inserted).</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">im</td><td>the image to draw onto for subsequent renderings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc1eaf179bc6573ab508ab3a7e38dab9" name="afc1eaf179bc6573ab508ab3a7e38dab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1eaf179bc6573ab508ab3a7e38dab9">&#9670;&#160;</a></span>setOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the offset of the image relative to the viewport. </p>
<p >If the image has size <code>(sx,sy)</code>, then during rasterization the portion <code>[ox, ox + sx[x[oy, oy+sy[</code> of the viewport will be drawn onto the image.</p>
<p >By changing the offset and redrawing several times it it possible to use an image smaller than the viewport (and also save on zbuffer space).</p>
<p >For example, to draw a 320x240 viewport with limited amount of memory. One can use an image of size 160x120 (37.5kb) and a z-buffer of the same size (35Kb for uint16_t) and then call the drawing method 4 times with offsets (0,0), (0,120), (160,0) and (160,120) and upload the resulting images at their correct positions on the screen between each rendering.</p>
<p >0warning Do not forget to clear the z-buffer after changing the offset !</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ox,oy</td><td>Offset of the image inside the viewport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae4fa24bc6a4c5235df0ae3e112c48b3" name="aae4fa24bc6a4c5235df0ae3e112c48b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4fa24bc6a4c5235df0ae3e112c48b3">&#9670;&#160;</a></span>setOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the offset of the image relative to the viewport. </p>
<p >Same as <code><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9" title="Set the offset of the image relative to the viewport.">setOffset(int ox, int oy)</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset of the image inside the viewport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0c31304f8ec4425401629a7846adff5" name="af0c31304f8ec4425401629a7846adff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c31304f8ec4425401629a7846adff5">&#9670;&#160;</a></span>setProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the projection matrix. </p>
<p >This is the matrix that is used to project coordinate from 'view space' to normalized device coordinates (NDC).</p>
<p >Call this method to set a "custom" projection matrix. For the usual perspective and orthographic matrices, use instead <a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545" title="Set the projection matrix as a perspective matrix.">setFrustum()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456" title="Set the projection matrix as a perspective matrix.">setPerspective()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f" title="Set the projection matrix as an orthographic matrix.">setOrtho()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the projection matrix to use (an internal copy is made). <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>When using perspective projection, the projection matrix must store <code>-z</code> into the <code>w</code> component.</li>
<li>In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl).</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a4bce4752b73a38862733b4f2bcb6f04f" title="Return the current projection matrix.">getProjectionMatrix()</a> </dd></dl>

</div>
</div>
<a id="a4bce4752b73a38862733b4f2bcb6f04f" name="a4bce4752b73a38862733b4f2bcb6f04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bce4752b73a38862733b4f2bcb6f04f">&#9670;&#160;</a></span>getProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::getProjectionMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current projection matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy ot hte current projection matrix. </dd></dl>

</div>
</div>
<a id="acf7c15aa00b471522a50af525cf41032" name="acf7c15aa00b471522a50af525cf41032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7c15aa00b471522a50af525cf41032">&#9670;&#160;</a></span>useOrthographicProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::useOrthographicProjection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set projection mode to orthographic (ie no z-divide). </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is called automatically after <code><a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f" title="Set the projection matrix as an orthographic matrix.">setOrtho()</a></code> so it needs only be called, when applicable, after <code><a class="el" href="classtgx_1_1_renderer3_d.html#af0c31304f8ec4425401629a7846adff5" title="Set the projection matrix.">setProjectionMatrix()</a></code>. </dd></dl>

</div>
</div>
<a id="a7bff46c6c71c78546267d7b75bb12644" name="a7bff46c6c71c78546267d7b75bb12644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bff46c6c71c78546267d7b75bb12644">&#9670;&#160;</a></span>usePerspectiveProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::usePerspectiveProjection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set projection mode to perspective (ie with z-divide). </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is called automatically after <code><a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456" title="Set the projection matrix as a perspective matrix.">setPerspective()</a></code> or <code><a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545" title="Set the projection matrix as a perspective matrix.">setFrustum()</a></code> so it needs only be called, when applicable, after <code><a class="el" href="classtgx_1_1_renderer3_d.html#af0c31304f8ec4425401629a7846adff5" title="Set the projection matrix.">setProjectionMatrix()</a></code>. </dd></dl>

</div>
</div>
<a id="a8ff9976b53c527e62c95be427620685f" name="a8ff9976b53c527e62c95be427620685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9976b53c527e62c95be427620685f">&#9670;&#160;</a></span>setOrtho()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setOrtho </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the projection matrix as an orthographic matrix. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml</a></p>
<p >This method automatically switches to orthographic projection mode by calling <a class="el" href="classtgx_1_1_renderer3_d.html#acf7c15aa00b471522a50af525cf41032" title="Set projection mode to orthographic (ie no z-divide).">useOrthographicProjection()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left,right</td><td>coordinates for the left and right vertical clipping planes </td></tr>
    <tr><td class="paramname">bottom,top</td><td>coordinates for the bottom and top horizontal clipping planes. </td></tr>
    <tr><td class="paramname">zNear,zFar</td><td>distances to the nearer and farther depth clipping planes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545" title="Set the projection matrix as a perspective matrix.">setFrustum()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456" title="Set the projection matrix as a perspective matrix.">setPerspective()</a>, , <a class="el" href="structtgx_1_1_mat4.html#aa427edd629ed08570dd5c8207a78db2e" title="Set as an orthographic projection matrix.">Mat4::setOrtho()</a> </dd></dl>

</div>
</div>
<a id="af0ae032c0be73580be8e61c53ad42545" name="af0ae032c0be73580be8e61c53ad42545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ae032c0be73580be8e61c53ad42545">&#9670;&#160;</a></span>setFrustum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setFrustum </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the projection matrix as a perspective matrix. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml</a></p>
<p >This method automatically switches to perspective projection mode by calling <a class="el" href="classtgx_1_1_renderer3_d.html#a7bff46c6c71c78546267d7b75bb12644" title="Set projection mode to perspective (ie with z-divide).">usePerspectiveProjection()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left,right</td><td>coordinates for the left and right vertical clipping planes </td></tr>
    <tr><td class="paramname">bottom,top</td><td>coordinates for the bottom and top horizontal clipping planes. </td></tr>
    <tr><td class="paramname">zNear,zFar</td><td>distances to the nearer and farther depth clipping planes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f" title="Set the projection matrix as an orthographic matrix.">setOrtho()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456" title="Set the projection matrix as a perspective matrix.">setPerspective()</a>, <a class="el" href="structtgx_1_1_mat4.html#a8f023a5d8bb793c6411a74a57c92e161" title="Set as a perspective projection matrix.">Mat4::setFrustum()</a> </dd></dl>

</div>
</div>
<a id="a8437622c6b90f9429769504848d22456" name="a8437622c6b90f9429769504848d22456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8437622c6b90f9429769504848d22456">&#9670;&#160;</a></span>setPerspective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setPerspective </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the projection matrix as a perspective matrix. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a></p>
<p >This method automatically switches to perspective projection mode by calling <a class="el" href="classtgx_1_1_renderer3_d.html#a7bff46c6c71c78546267d7b75bb12644" title="Set projection mode to perspective (ie with z-divide).">usePerspectiveProjection()</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovy</td><td>field of view angle, in degrees, in the y direction. </td></tr>
    <tr><td class="paramname">aspect</td><td>aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height). </td></tr>
    <tr><td class="paramname">zNear</td><td>distance from the viewer to the near clipping plane. </td></tr>
    <tr><td class="paramname">zFar</td><td>distance from the viewer to the far clipping plane.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545" title="Set the projection matrix as a perspective matrix.">setFrustum()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f" title="Set the projection matrix as an orthographic matrix.">setOrtho()</a>, <a class="el" href="structtgx_1_1_mat4.html#a1d162f853afbd66782cd6589596770b6" title="Set as a perspective projection matrix.">Mat4::setPerspective()</a> </dd></dl>

</div>
</div>
<a id="a76fa32770476cd15f717d3f103fd752d" name="a76fa32770476cd15f717d3f103fd752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fa32770476cd15f717d3f103fd752d">&#9670;&#160;</a></span>setCulling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setCulling </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the face culling strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Culling direction<ul>
<li><code>w&gt;0</code>: Vertices in front faces are ordered counter-clockwise [default]. Clockwise faces are culled.</li>
<li><code>w&lt;0</code>: Vertices in front faces are ordered clockwise. Counter-clockwise faces are culled.</li>
<li><code>w=0</code>: Disables face culling: both clockwise and counter-clockwise faces are drawn.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ol type="1">
<li>When face culling is enabled (<code>w != 0</code>), and when Gouraud shading is active, the normal vectors supplied for the vertices must be the normal vectors for the front side of the triangle.</li>
<li>When face culling is disabled (<code>w = 0</code>). Both faces of a triangle are drawn so there is no more notion of 'front' and 'back' face. In this case, when using Gouraud shading, by convention, the normal vector supplied must be those corresponding to the counter-clockwise face being shown (whatever this means since these normals vector are attached to vertices and not faces anyway, but still...) </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a516e700a5470f52cbd9a82dd59f8c968" name="a516e700a5470f52cbd9a82dd59f8c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516e700a5470f52cbd9a82dd59f8c968">&#9670;&#160;</a></span>setZbuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setZbuffer </td>
          <td>(</td>
          <td class="paramtype">ZBUFFER_t *&#160;</td>
          <td class="paramname"><em>zbuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the z-buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>The zbuffer must be large enough to be used with the image that is being drawn onto. This means that we must have length at least <code>image.width()*image.height()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuffer</td><td>pointer to the z-buffer to use from now one (replace the previous one if any) or nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ol type="1">
<li>Setting a valid zbuffer automatically turns on z-buffer depth test.</li>
<li>Removing the z-buffer (by setting it to <code>nullptr</code>) turns off the z-buffer depth test. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ad613bdffc57596703abe1a2a47583003" name="ad613bdffc57596703abe1a2a47583003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad613bdffc57596703abe1a2a47583003">&#9670;&#160;</a></span>clearZbuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::clearZbuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the Zbuffer. </p>
<p >This method must be called before drawing a new frame to erase the previous zbuffer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The z-buffer is intentionally not cleared between draw() calls to enable rendering of multiple objects on the same scene. </dd></dl>

</div>
</div>
<a id="a2547893a21094d5f23473ca8d3f7ee36" name="a2547893a21094d5f23473ca8d3f7ee36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2547893a21094d5f23473ca8d3f7ee36">&#9670;&#160;</a></span>setShaders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setShaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a>&#160;</td>
          <td class="paramname"><em>shaders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the shaders to use for subsequent drawing operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaders</td><td>flags to use (or'ed together with <code>|</code>).</td></tr>
  </table>
  </dd>
</dl>
<p>See enum <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07" title="List of shaders available for 3D graphics.">tgx::Shader</a> for a complete list of flags. <br  />
</p>
<p ><b>Main flags</b></p>
<ul>
<li><code>SHADER_FLAT</code>: Use flat shading (i.e. uniform color on faces). This is the fastest drawing method but it usually gives poor results when combined with texturing. Lighting transitions between bright to dark aera may appear to flicker when using color with low resolution such as <a class="el" href="structtgx_1_1_r_g_b565.html" title="Color in R5/G6/B5 format.">RGB565</a>.</li>
<li><code>SHADER_GOURAUD</code>: Use gouraud shading (linear interpolation of vertex colors) This results in smoother color transitions and works well with texturing but is more CPU intensive.</li>
<li><code>SHADER_TEXTURE</code>: enable texture mapping. A texture must be stored in an Image&lt;color_t&gt; object.<ul>
<li>wrap mode can be set with <a class="el" href="classtgx_1_1_renderer3_d.html#a5eb0863850052e0f5d4c4156cdd5e8b4" title="Set the wrap mode when for texturing.">setTextureWrappingMode()</a> or passing along either <code>SHADER_TEXTURE_WRAP_POW2</code> or <code>SHADER_TEXTURE_CLAMP</code>.</li>
<li>drawing quality can be set with <a class="el" href="classtgx_1_1_renderer3_d.html#af16b835173d22fc203451cd205cb2d34" title="Set the texturing quality.">setTextureQuality()</a> or by passing along either <code>SHADER_TEXTURE_NEAREST</code> or <code>SHADER_TEXTURE_BILINEAR</code>.</li>
</ul>
</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd><br  />
<ol type="1">
<li>If a shader flag is set with SetShaders() but is disabled in the template parameter LOADED_SHADER, then the drawing calls will silently fail (draw nothing).</li>
<li>The color on the face (for flat shading) or on the vertices (for gouraud shading) is computed according to Phong's lightning <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a>.</li>
<li>Texture mapping is 'perspective correct' and can be done with either SHADER_FLAT or SHADER_GOURAUD <br  />
 selected. The color of a pixel is obtained by combining to texture color at that pixel with the lightning at the position according to phong's lightning model.</li>
<li>For large textures stored in flash memory may be VERY slow to access when the texture is not read linearly which will happens for some (bad) triangle orientations and then cache becomes useless... This problem can be somewhat mitigated by:<ul>
<li>splitting large textured triangles into smaller ones: then each triangle only accesses a small part of the texture. This helps a lot wich cache optimization (this is why models with thousands of faces may display faster that a simple textured cube in some cases).</li>
<li>moving the image into RAM if possible. Even moving the texture from FLASH to EXTMEM (if available) will usually give a great speed boost ! </li>
</ul>
</li>
</ol>
</dd></dl>

</div>
</div>
<a id="a5eb0863850052e0f5d4c4156cdd5e8b4" name="a5eb0863850052e0f5d4c4156cdd5e8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb0863850052e0f5d4c4156cdd5e8b4">&#9670;&#160;</a></span>setTextureWrappingMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setTextureWrappingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a>&#160;</td>
          <td class="paramname"><em>wrap_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wrap mode when for texturing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrap_mode</td><td>Wrapping mode flag:<ul>
<li><code>SHADER_TEXTURE_WRAP_POW2</code>: Wrap around (repeat) the texture. This is the fastest mode but <b>the texture size must be a power of two along each dimension</b>.</li>
<li><code>SHADER_TEXTURE_CLAMP</code>: Clamp to the edge. A bit slower than above but the texture can be any size. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af16b835173d22fc203451cd205cb2d34" name="af16b835173d22fc203451cd205cb2d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16b835173d22fc203451cd205cb2d34">&#9670;&#160;</a></span>setTextureQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setTextureQuality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a>&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the texturing quality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quality</td><td>Texture quality flag:<ul>
<li><code>SHADER_TEXTURE_NEAREST</code>: Use simple point sampling when texturing (fastest method).</li>
<li><code>SHADER_TEXTURE_BILINEAR</code>: Use bilinear interpolation when texturing (slower but higher quality). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cad095ff0d7eefbdb93ac04b6a3efff" name="a6cad095ff0d7eefbdb93ac04b6a3efff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cad095ff0d7eefbdb93ac04b6a3efff">&#9670;&#160;</a></span>setViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the view transformation matrix. </p>
<p >This matrix is used to transform vertices from 'world coordinates' to 'view coordinates' (ie from the point of view of the camera).</p>
<p >Changing this matrix changes the position of the camera in the world space.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In view space (i.e. after transformation), the camera is assumed to be centered at the origin, looking toward the negative Z axis with the Y axis pointing up (as in opengl).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the view matrix to use (a copy is made).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a35bf226bb8236ad48314bca2bd0f31f8" title="Return the current view matrix.">getViewMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#abd6d8dbf64d64db311eb2854bdf1ceb1" title="Set the view matrix so that the camera is looking at a given direction.">setLookAt()</a> </dd></dl>

</div>
</div>
<a id="a35bf226bb8236ad48314bca2bd0f31f8" name="a35bf226bb8236ad48314bca2bd0f31f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bf226bb8236ad48314bca2bd0f31f8">&#9670;&#160;</a></span>getViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::getViewMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current view matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the view matrix.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff" title="Set the view transformation matrix.">setViewMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#abd6d8dbf64d64db311eb2854bdf1ceb1" title="Set the view matrix so that the camera is looking at a given direction.">setLookAt()</a> </dd></dl>

</div>
</div>
<a id="abd6d8dbf64d64db311eb2854bdf1ceb1" name="abd6d8dbf64d64db311eb2854bdf1ceb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6d8dbf64d64db311eb2854bdf1ceb1">&#9670;&#160;</a></span>setLookAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLookAt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eyeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eyeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eyeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centerX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centerY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centerZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the view matrix so that the camera is looking at a given direction. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eyeX,eyeY,eyeZ</td><td>position of the camera in world space coords. </td></tr>
    <tr><td class="paramname">centerX,centerY,centerZ</td><td>point the camera is looking toward in world space coords. </td></tr>
    <tr><td class="paramname">upX,upY,upZ</td><td>vector that tells the up direction for the camera (in world space coords).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff" title="Set the view transformation matrix.">setViewMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a35bf226bb8236ad48314bca2bd0f31f8" title="Return the current view matrix.">getViewMatrix()</a>, <a class="el" href="structtgx_1_1_mat4.html#a559673dc298b417ba65468510c291c93" title="Set the matrix for a camera looking at a given direction.">Mat4::setLookAt()</a> </dd></dl>

</div>
</div>
<a id="a386ac9391f31bdefc331def7359970eb" name="a386ac9391f31bdefc331def7359970eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386ac9391f31bdefc331def7359970eb">&#9670;&#160;</a></span>setLookAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the view matrix so that the camera is looking at a given direction. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eye</td><td>position of the camera in world space coords. </td></tr>
    <tr><td class="paramname">center</td><td>point the camera is looking toward in world space coords. </td></tr>
    <tr><td class="paramname">up</td><td>vector that tells the up direction for the camera (in world space coords).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff" title="Set the view transformation matrix.">setViewMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a35bf226bb8236ad48314bca2bd0f31f8" title="Return the current view matrix.">getViewMatrix()</a>, <a class="el" href="structtgx_1_1_mat4.html#a559673dc298b417ba65468510c291c93" title="Set the matrix for a camera looking at a given direction.">Mat4::setLookAt()</a> </dd></dl>

</div>
</div>
<a id="a63284e47ac2f832f122df06bcbd3193a" name="a63284e47ac2f832f122df06bcbd3193a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63284e47ac2f832f122df06bcbd3193a">&#9670;&#160;</a></span>worldToNDC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::worldToNDC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from world coordinates to normalized device coordinates (NDC). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Point in the word coordinate system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of <code>P</code> on the standard viewport <code>[-1,1]^2</code> according to the current position of the camera.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>the model matrix is not taken into account here.</li>
<li>the <code>w</code> value returned can be used for depth testing. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a76c4ce4af7e3c7da2e3a1a7d1d0d4f01" name="a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c4ce4af7e3c7da2e3a1a7d1d0d4f01">&#9670;&#160;</a></span>worldToImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::worldToImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from world coordinates to the corresponding image pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Point in the word coordinate system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of the associated pixel on the image.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The position returned may be outside of the image !</li>
<li>Returns (0,0) if no image is inserted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a594bb296fe042612d4036c04ae1e2d1b" name="a594bb296fe042612d4036c04ae1e2d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594bb296fe042612d4036c04ae1e2d1b">&#9670;&#160;</a></span>setLightDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLightDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the light source direction. </p>
<p >The 3d rendered uses a single 'directional light' i.e. a light source comming from infinity (such as the sun).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The direction the light point toward given in world coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5ad40825895c5cb3a675fb15c2035d97" title="Set all the lighting parameters of the scene at once.">setLight()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a412610fe5ada143bfcf9cc017bda809d" title="Set the scene ambiant light color.">setLightAmbiant()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aad5463cb7ba2f16fa1cf184999acf7f5" title="Set the scene diffuse light color.">setLightDiffuse()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aae01958e81972d5bdd3392fbe23eda6a" title="Set the scene specular light color.">setLightSpecular()</a> </dd></dl>

</div>
</div>
<a id="a412610fe5ada143bfcf9cc017bda809d" name="a412610fe5ada143bfcf9cc017bda809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412610fe5ada143bfcf9cc017bda809d">&#9670;&#160;</a></span>setLightAmbiant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLightAmbiant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scene ambiant light color. </p>
<p >See Phong's lightning model: <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>color for the ambiant light.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5ad40825895c5cb3a675fb15c2035d97" title="Set all the lighting parameters of the scene at once.">setLight()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b" title="Set the light source direction.">setLightDirection()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aad5463cb7ba2f16fa1cf184999acf7f5" title="Set the scene diffuse light color.">setLightDiffuse()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aae01958e81972d5bdd3392fbe23eda6a" title="Set the scene specular light color.">setLightSpecular()</a> </dd></dl>

</div>
</div>
<a id="aad5463cb7ba2f16fa1cf184999acf7f5" name="aad5463cb7ba2f16fa1cf184999acf7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5463cb7ba2f16fa1cf184999acf7f5">&#9670;&#160;</a></span>setLightDiffuse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLightDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scene diffuse light color. </p>
<p >See Phong's lightning model: <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>color for the difuse light.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5ad40825895c5cb3a675fb15c2035d97" title="Set all the lighting parameters of the scene at once.">setLight()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b" title="Set the light source direction.">setLightDirection()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a412610fe5ada143bfcf9cc017bda809d" title="Set the scene ambiant light color.">setLightAmbiant()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aae01958e81972d5bdd3392fbe23eda6a" title="Set the scene specular light color.">setLightSpecular()</a> </dd></dl>

</div>
</div>
<a id="aae01958e81972d5bdd3392fbe23eda6a" name="aae01958e81972d5bdd3392fbe23eda6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae01958e81972d5bdd3392fbe23eda6a">&#9670;&#160;</a></span>setLightSpecular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLightSpecular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scene specular light color. </p>
<p >See Phong's lightning model: <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>color for the specular light.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5ad40825895c5cb3a675fb15c2035d97" title="Set all the lighting parameters of the scene at once.">setLight()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b" title="Set the light source direction.">setLightDirection()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a412610fe5ada143bfcf9cc017bda809d" title="Set the scene ambiant light color.">setLightAmbiant()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aad5463cb7ba2f16fa1cf184999acf7f5" title="Set the scene diffuse light color.">setLightDiffuse()</a> </dd></dl>

</div>
</div>
<a id="a5ad40825895c5cb3a675fb15c2035d97" name="a5ad40825895c5cb3a675fb15c2035d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad40825895c5cb3a675fb15c2035d97">&#9670;&#160;</a></span>setLight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>ambiantColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>diffuseColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>specularColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the lighting parameters of the scene at once. </p>
<p >The 3d rendered uses a single 'directional light' i.e. a light source comming from infinity (such as the sun).</p>
<p >See Phong's lightning model: <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>direction the light source point toward. </td></tr>
    <tr><td class="paramname">ambiantColor</td><td>light ambiant color. </td></tr>
    <tr><td class="paramname">diffuseColor</td><td>light diffuse color. </td></tr>
    <tr><td class="paramname">specularColor</td><td>light specular color.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b" title="Set the light source direction.">setLightDirection()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a412610fe5ada143bfcf9cc017bda809d" title="Set the scene ambiant light color.">setLightAmbiant()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aad5463cb7ba2f16fa1cf184999acf7f5" title="Set the scene diffuse light color.">setLightDiffuse()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#aae01958e81972d5bdd3392fbe23eda6a" title="Set the scene specular light color.">setLightSpecular()</a> </dd></dl>

</div>
</div>
<a id="a7ca1f0b53ca7460869fc3031f8422240" name="a7ca1f0b53ca7460869fc3031f8422240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca1f0b53ca7460869fc3031f8422240">&#9670;&#160;</a></span>setModelMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setModelMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the model tranformation matrix. </p>
<p >This matrix describes the transformation from local object space to view space. (i.e. the matrix specifies the position of the object in world space).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the new model transformation matrix (a copy is made).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a92666f8cccbb7233cae2fc07322efcc3" title="Return the model tranformation matrix.">getModelMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a29025a5ef39eaf15590bdba70b0e4e9d" title="Set the model tranformation matrix to move an object to a given a given location, scale and rotation.">setModelPosScaleRot()</a> </dd></dl>

</div>
</div>
<a id="a92666f8cccbb7233cae2fc07322efcc3" name="a92666f8cccbb7233cae2fc07322efcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92666f8cccbb7233cae2fc07322efcc3">&#9670;&#160;</a></span>getModelMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::getModelMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model tranformation matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the current model tranformation matrix.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a7ca1f0b53ca7460869fc3031f8422240" title="Set the model tranformation matrix.">setModelMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a29025a5ef39eaf15590bdba70b0e4e9d" title="Set the model tranformation matrix to move an object to a given a given location, scale and rotation.">setModelPosScaleRot()</a> </dd></dl>

</div>
</div>
<a id="a29025a5ef39eaf15590bdba70b0e4e9d" name="a29025a5ef39eaf15590bdba70b0e4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29025a5ef39eaf15590bdba70b0e4e9d">&#9670;&#160;</a></span>setModelPosScaleRot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setModelPosScaleRot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{&#160;0,&#160;0,&#160;0&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>(1,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rot_angle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>rot_dir</em> = <code><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{&#160;0,&#160;1,&#160;0&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the model tranformation matrix to move an object to a given a given location, scale and rotation. </p>
<p >The method is such that, if a model is initially centered around the origin in model coordinate, then it will be placed at a given position/scale/rotation in the world coordinates after multiplication by the model transformation matrix.</p>
<p >Transforms are done in the following order:</p>
<ol type="1">
<li>The model is scaled in each direction in the model coord. according to <code>scale</code></li>
<li>The model is rotated in model coord. around direction <code>rot_dir</code> and with an angle <code>rot_angle</code> (in degree).</li>
<li>The model is translated to position <code>center</code> in the world coord.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>new center position after transformation. </td></tr>
    <tr><td class="paramname">scale</td><td>scaling factor in each direction. </td></tr>
    <tr><td class="paramname">rot_angle</td><td>rotation angle (in degrees). </td></tr>
    <tr><td class="paramname">rot_dir</td><td>rotation axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a92666f8cccbb7233cae2fc07322efcc3" title="Return the model tranformation matrix.">getModelMatrix()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a7ca1f0b53ca7460869fc3031f8422240" title="Set the model tranformation matrix.">setModelMatrix()</a> </dd></dl>

</div>
</div>
<a id="ae5e7d7c90ab94776798b8031a30235f2" name="ae5e7d7c90ab94776798b8031a30235f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e7d7c90ab94776798b8031a30235f2">&#9670;&#160;</a></span>modelToNDC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::modelToNDC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from model coordinates to normalized device coordinates (NDC). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Point given in the model coordinate system. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the projection of <code>P</code> on the standard viewport <code>[-1,1]^2</code>` according to the current position of the camera.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the .w value can be used for depth testing. </dd></dl>

</div>
</div>
<a id="a27bb400f5ad09195a860f6f7ab3db71c" name="a27bb400f5ad09195a860f6f7ab3db71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bb400f5ad09195a860f6f7ab3db71c">&#9670;&#160;</a></span>modelToImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::modelToImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from model coordinates to the corresponding image pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Point given in the model coordinate system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the associated pixel on the image.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The position returned may be outside of the image !</li>
<li>Returns (0,0) if no image is inserted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5452d61ed252f1ccdce87834ffd8491f" name="a5452d61ed252f1ccdce87834ffd8491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5452d61ed252f1ccdce87834ffd8491f">&#9670;&#160;</a></span>setMaterialColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the object material color. </p>
<p >This is the color used to render the object when texturing is not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The material color.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003" title="Set how much the object material reflects the ambient light.">setMaterialAmbiantStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c" title="Set how much the object material reflects the diffuse light.">setMaterialDiffuseStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893" title="Set how much the object material reflects the specular light.">setMaterialSpecularStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e" title="Set the object specular exponent.">setMaterialSpecularExponent()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8" title="Set all the object material properties at once.">setMaterial()</a> </dd></dl>

</div>
</div>
<a id="a04afc9a2671e9cea42d62f0cf0c06003" name="a04afc9a2671e9cea42d62f0cf0c06003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04afc9a2671e9cea42d62f0cf0c06003">&#9670;&#160;</a></span>setMaterialAmbiantStrength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialAmbiantStrength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>strenght</em> = <code>0.1f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set how much the object material reflects the ambient light. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strenght</td><td>ambiant lightreflection strength in [0.0f,1.0f]. Default value 0.1f.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f" title="Set the object material color.">setMaterialColor()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c" title="Set how much the object material reflects the diffuse light.">setMaterialDiffuseStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893" title="Set how much the object material reflects the specular light.">setMaterialSpecularStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e" title="Set the object specular exponent.">setMaterialSpecularExponent()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8" title="Set all the object material properties at once.">setMaterial()</a> </dd></dl>

</div>
</div>
<a id="a24b59fb15f8464b2dbc690cf9244648c" name="a24b59fb15f8464b2dbc690cf9244648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b59fb15f8464b2dbc690cf9244648c">&#9670;&#160;</a></span>setMaterialDiffuseStrength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialDiffuseStrength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>strenght</em> = <code>0.6f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set how much the object material reflects the diffuse light. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strenght</td><td>diffuse light reflection strength in [0.0f,1.0f]. Default value 0.6f.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f" title="Set the object material color.">setMaterialColor()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003" title="Set how much the object material reflects the ambient light.">setMaterialAmbiantStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893" title="Set how much the object material reflects the specular light.">setMaterialSpecularStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e" title="Set the object specular exponent.">setMaterialSpecularExponent()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8" title="Set all the object material properties at once.">setMaterial()</a> </dd></dl>

</div>
</div>
<a id="a20831a50013228afa468783499f44893" name="a20831a50013228afa468783499f44893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20831a50013228afa468783499f44893">&#9670;&#160;</a></span>setMaterialSpecularStrength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialSpecularStrength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>strenght</em> = <code>0.5f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set how much the object material reflects the specular light. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strenght</td><td>specular light reflection strength in [0.0f,1.0f]. Default value 0.5f.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f" title="Set the object material color.">setMaterialColor()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003" title="Set how much the object material reflects the ambient light.">setMaterialAmbiantStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c" title="Set how much the object material reflects the diffuse light.">setMaterialDiffuseStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e" title="Set the object specular exponent.">setMaterialSpecularExponent()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8" title="Set all the object material properties at once.">setMaterial()</a> </dd></dl>

</div>
</div>
<a id="a0c4d3e69db91b78e7b86cfa8a239e54e" name="a0c4d3e69db91b78e7b86cfa8a239e54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4d3e69db91b78e7b86cfa8a239e54e">&#9670;&#160;</a></span>setMaterialSpecularExponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialSpecularExponent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>16</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the object specular exponent. </p>
<p >The epxonent should be range between 0 (no specular lightning) and 100 (very localized/glossy).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exponent</td><td>Specular exponent in [0,100]. Default value 16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f" title="Set the object material color.">setMaterialColor()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003" title="Set how much the object material reflects the ambient light.">setMaterialAmbiantStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c" title="Set how much the object material reflects the diffuse light.">setMaterialDiffuseStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893" title="Set how much the object material reflects the specular light.">setMaterialSpecularStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a5ae2f4be4d9c231fdd4f8f624a80a4e8" title="Set all the object material properties at once.">setMaterial()</a> </dd></dl>

</div>
</div>
<a id="a5ae2f4be4d9c231fdd4f8f624a80a4e8" name="a5ae2f4be4d9c231fdd4f8f624a80a4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae2f4be4d9c231fdd4f8f624a80a4e8">&#9670;&#160;</a></span>setMaterial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ambiantStrength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>diffuseStrength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>specularStrength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>specularExponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the object material properties at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The material color. </td></tr>
    <tr><td class="paramname">ambiantStrength</td><td>The ambiant light reflection strength. </td></tr>
    <tr><td class="paramname">diffuseStrength</td><td>The diffuse light reflection strength. </td></tr>
    <tr><td class="paramname">specularStrength</td><td>The specular light reflection strength. </td></tr>
    <tr><td class="paramname">specularExponent</td><td>The specular exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f" title="Set the object material color.">setMaterialColor()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a04afc9a2671e9cea42d62f0cf0c06003" title="Set how much the object material reflects the ambient light.">setMaterialAmbiantStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a24b59fb15f8464b2dbc690cf9244648c" title="Set how much the object material reflects the diffuse light.">setMaterialDiffuseStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a20831a50013228afa468783499f44893" title="Set how much the object material reflects the specular light.">setMaterialSpecularStrength()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e" title="Set the object specular exponent.">setMaterialSpecularExponent()</a>, </dd></dl>

</div>
</div>
<a id="a0298855a66fc0063e3c935dabac4c51e" name="a0298855a66fc0063e3c935dabac4c51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0298855a66fc0063e3c935dabac4c51e">&#9670;&#160;</a></span>drawMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_mesh_material</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a <a class="el" href="structtgx_1_1_mesh3_d.html" title="3D mesh data stucture.">Mesh3D</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to draw. </td></tr>
    <tr><td class="paramname">use_mesh_material</td><td>True (default) to use mesh material, otherwise use the current material instead. this flag affects also all the linked meshes if <code>draw_chained_meshes=true</code>. </td></tr>
    <tr><td class="paramname">draw_chained_meshes</td><td>True (default) to draw also the chained meshes, in any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Drawing a mesh is the most effective way of drawing a 3D object (faster than drawing individual triangles/quads) so it should be the prefered method whenever working with static geometry.</li>
<li>The mesh can be located in any memory region (RAM, FLASH...) but using a fast memory will <br  />
 improve renderin speed noticeably. The methods <code><a class="el" href="_mesh3_d_8h.html#a702507b5a357a4e5d538c0851118e5ea" title="Creates a &quot;cache version&quot; of a mesh by copying part of its data into fast memory buffers.">cacheMesh()</a></code> (or <code><a class="el" href="_mesh3_d_8h.html#aa0e5c4ceb583a160ecfbd2b699966a43" title="Create a copy of a mesh where specified arrays in PROGMEM are copied to EXTMEM.">copyMeshEXTMEM()</a></code> on Teensy) are available to copy a mesh to a faster memory location before rendering. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad08c1eab35027a61fee8a22c68ea348d" name="ad08c1eab35027a61fee8a22c68ea348d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08c1eab35027a61fee8a22c68ea348d">&#9670;&#160;</a></span>drawTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3</td><td>coordinates (in model space) of the triangle to draw </td></tr>
    <tr><td class="paramname">N1,N2,N3</td><td>pointers to the normals associated with <code>P1, P2, P3</code> or <code>nullptr</code> if not using Gouraud shading. </td></tr>
    <tr><td class="paramname">T1,T2,T3</td><td>pointer to the texture coords. <code>nullptr</code> if not using texturing. </td></tr>
    <tr><td class="paramname">texture</td><td>pointer to the texture image or <code>nullptr</code> if not using texturing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The triangle is drawn with the current color/material.</li>
<li><code>P1,P2,P3</code> must be in the correct winding order (c.f. <a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d" title="Set the face culling strategy.">setCulling()</a>). <br  />
</li>
<li>the normals <code>N1,N2,N3</code> are mandatory with Gouraud shading and must have unit norm. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7bb17f3177a24fbeccbb0d8a801aef88" name="a7bb17f3177a24fbeccbb0d8a801aef88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb17f3177a24fbeccbb0d8a801aef88">&#9670;&#160;</a></span>drawTriangleWithVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawTriangleWithVertexColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single triangle with a given colors on each of its vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3</td><td>coordinates (in model space) of the triangle to draw </td></tr>
    <tr><td class="paramname">col1,col2,col3</td><td>color at each vertex. </td></tr>
    <tr><td class="paramname">N1,N2,N3</td><td>pointers to the normals associated with <code>P1, P2, P3</code> or <code>nullptr</code> if not using Gouraud shading.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The color inside the triangle is obtained by linear interpolation.</li>
<li><code>P1,P2,P3</code> must be in the correct winding order (c.f. <a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d" title="Set the face culling strategy.">setCulling()</a>).</li>
<li>the normals <code>N1,N2,N3</code> are mandatory with Gouraud shading and must have unit norm. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad54f3bb4aedeeee2efbb8aa9956bf17a" name="ad54f3bb4aedeeee2efbb8aa9956bf17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54f3bb4aedeeee2efbb8aa9956bf17a">&#9670;&#160;</a></span>drawTriangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_texture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>textures</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_image</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_triangles</td><td>number of triangles to draw. </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>Array of vertex indexes. The length of the array is <code>nb_triangles*3</code> and each 3 consecutive values represent a triangle. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices (in model space). </td></tr>
    <tr><td class="paramname">ind_normals</td><td>Array of normal indexes. If specified, the array must have length <code>nb_triangles*3</code>. </td></tr>
    <tr><td class="paramname">normals</td><td>The array of normals vectors (in model space). </td></tr>
    <tr><td class="paramname">ind_texture</td><td>array of texture indexes. If specified, the array must have length <code>nb_triangles*3</code>. </td></tr>
    <tr><td class="paramname">textures</td><td>The array of texture coords. </td></tr>
    <tr><td class="paramname">texture_image</td><td>The texture image to use or <code>nullptr</code> if not used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If Gouraud shading is enabled, the normal vector must all have have unit norm.</li>
<li>If Gouraud shading is disabled, <code>ind_normals</code> and <code>normals</code> should be set to <code>nullptr</code>. <br  />
</li>
<li>If texturing is disabled, <code>ind_texture</code>, <code>textures</code> and <code>texture_image</code> should be set to <code>nullptr</code>. <br  />
</li>
<li>If texturing is disabled, the current material color is used to draw the triangles. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afc1acda7d8cb5a16666acdb3306dcdd3" name="afc1acda7d8cb5a16666acdb3306dcdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1acda7d8cb5a16666acdb3306dcdd3">&#9670;&#160;</a></span>drawQuad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single quad. </p>
<p ><b>The four vertices of the quad must be co-planar !</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3,P4</td><td>coordinates (in model space) of the quad to draw </td></tr>
    <tr><td class="paramname">N1,N2,N3,N4</td><td>pointers to the normals associated with <code>P1, P2, P3, P4</code> or <code>nullptr</code> if not using Gouraud shading. </td></tr>
    <tr><td class="paramname">T1,T2,T3,T4</td><td>pointer to the texture coords. <code>nullptr</code> if not using texturing. </td></tr>
    <tr><td class="paramname">texture</td><td>pointer to the texture image or <code>nullptr</code> if not using texturing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The quad is drawn with the current color/material.</li>
<li><code>P1,P2,P3,P4</code> must be in the correct winding order (c.f. <a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d" title="Set the face culling strategy.">setCulling()</a>).</li>
<li>the normals <code>N1,N2,N3,N4</code> are mandatory with Gouraud shading and must have unit norm. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="addff7a6a3a439659704d29b524b7f6b2" name="addff7a6a3a439659704d29b524b7f6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addff7a6a3a439659704d29b524b7f6b2">&#9670;&#160;</a></span>drawQuadWithVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawQuadWithVertexColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N4</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single quad with a given colors on each of its four vertices. </p>
<p ><b>The four vertices of the quad must be co-planar !</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3,P4</td><td>coordinates (in model space) of the quad to draw </td></tr>
    <tr><td class="paramname">col1,col2,col3,col4</td><td>color at each vertex. </td></tr>
    <tr><td class="paramname">N1,N2,N3,N4</td><td>pointers to the normals associated with <code>P1, P2, P3, P4</code> or <code>nullptr</code> if not using Gouraud shading.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The color inside the quad is obtained by linear interpolation.</li>
<li><code>P1,P2,P3,P4</code> must be in the correct winding order (c.f. <a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d" title="Set the face culling strategy.">setCulling()</a>).</li>
<li>the normals <code>N1,N2,N3,N4</code> are mandatory with Gouraud shading and must have unit norm. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a01fe01f23d0925292db43938f164d5ad" name="a01fe01f23d0925292db43938f164d5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fe01f23d0925292db43938f164d5ad">&#9670;&#160;</a></span>drawQuads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_texture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>textures</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_image</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of quads. </p>
<p ><b>The four vertices of a quad must always be co-planar !</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_quads</td><td>number of quads to draw. </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>Array of vertex indexes. The length of the array is <code>nb_quads*4</code> and each 4 consecutive values represent a quad. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices (in model space). </td></tr>
    <tr><td class="paramname">ind_normals</td><td>Array of normal indexes. If specified, the array must have length <code>nb_quads*4</code>. </td></tr>
    <tr><td class="paramname">normals</td><td>The array of normals vectors (in model space). </td></tr>
    <tr><td class="paramname">ind_texture</td><td>array of texture indexes. If specified, the array must have length <code>nb_quads*4</code>. </td></tr>
    <tr><td class="paramname">textures</td><td>The array of texture coords. </td></tr>
    <tr><td class="paramname">texture_image</td><td>The texture image to use or <code>nullptr</code> if not used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If Gouraud shading is enabled, the normal vector must all have have unit norm.</li>
<li>If Gouraud shading is disabled, <code>ind_normals</code> and <code>normals</code> should be set to <code>nullptr</code>.</li>
<li>If texturing is disabled, <code>ind_texture</code>, <code>textures</code> and <code>texture_image</code> should be set to <code>nullptr</code>.</li>
<li>If texturing is disabled, the current material color is used to draw the quads. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a44f87bfade3e549ef8b3ec2468705e77" name="a44f87bfade3e549ef8b3ec2468705e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f87bfade3e549ef8b3ec2468705e77">&#9670;&#160;</a></span>drawCube() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawCube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw the unit cube <code>[-1,1]^3</code> in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The model transform matrix may be used to scale, rotate and position the cube anywhere in world space. </dd></dl>

</div>
</div>
<a id="ab32f027d40abe77c230d9975482d6488" name="ab32f027d40abe77c230d9975482d6488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32f027d40abe77c230d9975482d6488">&#9670;&#160;</a></span>drawCube() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_front_ABCD</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_back_EFGH</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_top_HADE</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_bottom_BGFC</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_left_HGBA</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_right_DCFE</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a textured unit cube <code>[-1,1]^3</code> in model space. </p>
<div class="fragment"><div class="line">                                             H--------E</div>
<div class="line">                                             |        |</div>
<div class="line">                                             |  top   |</div>
<div class="line">    H-------------E                          |        |</div>
<div class="line">   /.            /|                 H--------A--------D--------E</div>
<div class="line">  / .   top     / |                 |        |        |        |</div>
<div class="line"> /  .          /  |                 |  left  | front  |  right |</div>
<div class="line">A------------D    |  right          |        |        |        |</div>
<div class="line">|   .        |    |                 G--------B--------C--------F</div>
<div class="line">|   G .......|....F                          |        |</div>
<div class="line">|  .         |   /                           | bottom |</div>
<div class="line">| .  front   |  /                            |        |</div>
<div class="line">|.           | /                             G--------F</div>
<div class="line">B------------C                               |        |</div>
<div class="line">                                             |  back  |</div>
<div class="line">                                             |        |</div>
<div class="line">                                             H--------E</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used to scale, rotate and position the cube anywhere in world space.</li>
<li>Each face may use a different texture (or set the image to <code>nullptr</code> to disable texturing a face). <br  />
</li>
<li>This method is useful for drawing a sky-box.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_front_ABCD</td><td>texture coords array for the front face in order ABCD </td></tr>
    <tr><td class="paramname">texture_front</td><td>texture for the front face </td></tr>
    <tr><td class="paramname">v_back_EFGH</td><td>texture coords array for the back face in order EFGH </td></tr>
    <tr><td class="paramname">texture_back</td><td>texture for the back face </td></tr>
    <tr><td class="paramname">v_top_HADE</td><td>texture coords array for the top face in order HADE </td></tr>
    <tr><td class="paramname">texture_top</td><td>texture for the top face </td></tr>
    <tr><td class="paramname">v_bottom_BGFC</td><td>texture coords array for the bottom face in order BGFC </td></tr>
    <tr><td class="paramname">texture_bottom</td><td>texture for the bottom face </td></tr>
    <tr><td class="paramname">v_left_HGBA</td><td>texture coords array for the left face in order HGBA </td></tr>
    <tr><td class="paramname">texture_left</td><td>texture for the left face </td></tr>
    <tr><td class="paramname">v_right_DCFE</td><td>texture coords array for the right face in order DCFE </td></tr>
    <tr><td class="paramname">texture_right</td><td>texture for the right face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f4b0d511a4144826084788e5f69911a" name="a2f4b0d511a4144826084788e5f69911a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b0d511a4144826084788e5f69911a">&#9670;&#160;</a></span>drawCube() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>draw a textured unit cube [-1,1]^3 (in model space) </p>
<div class="fragment"><div class="line">                                             H--------E</div>
<div class="line">                                             |        |</div>
<div class="line">                                             |  top   |</div>
<div class="line">    H-------------E                          |        |</div>
<div class="line">   /.            /|                 H--------A--------D--------E</div>
<div class="line">  / .   top     / |                 |        |        |        |</div>
<div class="line"> /  .          /  |                 |  left  | front  |  right |</div>
<div class="line">A------------D    |  right          |        |        |        |</div>
<div class="line">|   .        |    |                 G--------B--------C--------F</div>
<div class="line">|   G .......|....F                          |        |</div>
<div class="line">|  .         |   /                           | bottom |</div>
<div class="line">| .  front   |  /                            |        |</div>
<div class="line">|.           | /                             G--------F</div>
<div class="line">B------------C                               |        |</div>
<div class="line">                                             |  back  |</div>
<div class="line">                                             |        |</div>
<div class="line">                                             H--------E</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used to scale, rotate and position the cube anywhere in world space.</li>
<li>Each face uses a 'whole' image. Set the texture image to <code>nullptr</code> to disable texturing a given face.</li>
<li>This method is useful for drawing a sky-box.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture_front</td><td>texture for the front face. </td></tr>
    <tr><td class="paramname">texture_back</td><td>texture for the back face. </td></tr>
    <tr><td class="paramname">texture_top</td><td>texture for the top face. </td></tr>
    <tr><td class="paramname">texture_bottom</td><td>texture for the bottom face. </td></tr>
    <tr><td class="paramname">texture_left</td><td>texture for the left face. </td></tr>
    <tr><td class="paramname">texture_right</td><td>texture for the right face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0737d0bed8e991bdda9c956e6842478d" name="a0737d0bed8e991bdda9c956e6842478d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0737d0bed8e991bdda9c956e6842478d">&#9670;&#160;</a></span>drawSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a unit radius sphere centered at the origin <code>S(0,1)</code> in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
<li>The mesh created is a UV-sphere with a given number of sector and stacks.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_sectors</td><td>number of sectors of the UV sphere. </td></tr>
    <tr><td class="paramname">nb_stacks</td><td>number of stacks of the UV sphere. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6fbb721753ca5a7f0f5237eb2ebbe01" name="ae6fbb721753ca5a7f0f5237eb2ebbe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fbb721753ca5a7f0f5237eb2ebbe01">&#9670;&#160;</a></span>drawSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a textured unit radius sphere centered at the origin S(0,1) in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
<li>The mesh created is a UV-sphere with a given number of sector and stacks.</li>
<li>The texture is mapped using the Mercator projection.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_sectors</td><td>number of sectors of the UV sphere. </td></tr>
    <tr><td class="paramname">nb_stacks</td><td>number of stacks of the UV sphere. </td></tr>
    <tr><td class="paramname">texture</td><td>The texture (mapped via Mercoator projection) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00c59fee77ca3d42b19d62e9eade1203" name="a00c59fee77ca3d42b19d62e9eade1203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c59fee77ca3d42b19d62e9eade1203">&#9670;&#160;</a></span>drawAdaptativeSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em> = <code>1.0f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a unit radius sphere centered at the origin S(0,1) in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
<li>The mesh created is a UV-sphere and the number of sector and stacks is adjusted automatically according to the apparent size on the screen.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quality</td><td>Quality of the mesh. Should be positive, typically between 0.5f and 2.0f.<ul>
<li><code>1</code> : default quality <br  />
</li>
<li><code>&gt;1</code>: finer mesh. Improve quality but decrease speed.</li>
<li><code>&lt;1</code>: coarser mesh. Decrease quality but improve speed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa9186b507df18e0df32976781d48909" name="afa9186b507df18e0df32976781d48909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9186b507df18e0df32976781d48909">&#9670;&#160;</a></span>drawAdaptativeSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a textured unit radius sphere centered at the origin S(0,1) in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used position the sphere anywhere in world space <br  />
 and change it to an ellipsoid.</li>
<li>The mesh created is a UV-sphere and the number of sector and stacks is adjusted <br  />
 automatically according to the apparent size on the screen.</li>
<li>The texture is mapped using the Mercator projection.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The texture image mapped via Mercator projection. </td></tr>
    <tr><td class="paramname">quality</td><td>(Optional) Quality of the mesh. Should be positive, typically between 0.5f and 2.0f.<ul>
<li><code>1</code> : default quality</li>
<li><code>&gt;1</code>: finer mesh. Improve quality but decrease speed.</li>
<li><code>&lt;1</code>: coarser mesh. Decrease quality but improve speed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae167aca012374ff0ebd009ca3a008df9" name="ae167aca012374ff0ebd009ca3a008df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae167aca012374ff0ebd009ca3a008df9">&#9670;&#160;</a></span>drawWireFrameMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a mesh in wireframe [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The mesh is drawn with the current material color (not that of the mesh). This method does not require a zbuffer but back face culling is used if it is enabled.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to draw </td></tr>
    <tr><td class="paramname">draw_chained_meshes</td><td>True to draw also the chained meshes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b34fbcf5759c1231f31a16e98ed667e" name="a3b34fbcf5759c1231f31a16e98ed667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b34fbcf5759c1231f31a16e98ed667e">&#9670;&#160;</a></span>drawWireFrameMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a mesh in wireframe [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>This method does not require a zbuffer but back face culling is used if it is enabled.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) ! <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to draw </td></tr>
    <tr><td class="paramname">draw_chained_meshes</td><td>True to draw also the chained meshes. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines. </td></tr>
    <tr><td class="paramname">color</td><td>color to use. </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a021ab6984464a4d7afe933d81bc5ef96" name="a021ab6984464a4d7afe933d81bc5ef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021ab6984464a4d7afe933d81bc5ef96">&#9670;&#160;</a></span>drawWireFrameLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe line segment [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The line is drawn with the current material color.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2</td><td>endpoints in model space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addb9598771b00af5e8aac070b4393231" name="addb9598771b00af5e8aac070b4393231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb9598771b00af5e8aac070b4393231">&#9670;&#160;</a></span>drawWireFrameLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe line segment [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2</td><td>endpoints in model space. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the line </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c8a63bd23b32cf1887940b92a352f08" name="a4c8a63bd23b32cf1887940b92a352f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8a63bd23b32cf1887940b92a352f08">&#9670;&#160;</a></span>drawWireFrameLines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of wireframe line segments [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The lines are drawn with the current material color.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_lines</td><td>number of lines to draw </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>array of vertex indices. The length of the array is <code>nb_lines*2</code> and each 2 consecutive values represent a line segment. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices in model space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a974433794ae62149a59273afbc50ed6e" name="a974433794ae62149a59273afbc50ed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974433794ae62149a59273afbc50ed6e">&#9670;&#160;</a></span>drawWireFrameLines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of wireframe line segments [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_lines</td><td>number of lines to draw </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>array of vertex indices. The length of the array is <code>nb_lines*2</code> and each 2 consecutive values represent a line segment. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices in model space. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12199857bf19951674f542a578642aa2" name="a12199857bf19951674f542a578642aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12199857bf19951674f542a578642aa2">&#9670;&#160;</a></span>drawWireFrameTriangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe triangle [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The lines are drawn with the current material color. <br  />
</li>
<li>This method does not use the z-buffer but backface culling is used if enabled.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3</td><td>the triangle vertices in model space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e6d9c3a846123139123791d3f416be5" name="a7e6d9c3a846123139123791d3f416be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6d9c3a846123139123791d3f416be5">&#9670;&#160;</a></span>drawWireFrameTriangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe triangle [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3</td><td>triangle vertices in model space. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbdfc3d33a5d201fd7bf8cd66d6b6e4c" name="afbdfc3d33a5d201fd7bf8cd66d6b6e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdfc3d33a5d201fd7bf8cd66d6b6e4c">&#9670;&#160;</a></span>drawWireFrameTriangles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of wireframe triangles [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The lines are drawn with the current material color.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled. <br  />
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_triangles</td><td>number of triangles to draw. </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>Array of vertex indexes. The length of the array is <code>nb_triangles*3</code> and each 3 consecutive values represent a triangle. </td></tr>
    <tr><td class="paramname">vertices</td><td>Array of vertices in model space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5eacbe59b3e28b1991d4d35992db563" name="ae5eacbe59b3e28b1991d4d35992db563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eacbe59b3e28b1991d4d35992db563">&#9670;&#160;</a></span>drawWireFrameTriangles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of wireframe triangles [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_triangles</td><td>number of triangles to draw. </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>Array of vertex indexes. The length of the array is <code>nb_triangles*3</code> and each 3 consecutive values represent a triangle. </td></tr>
    <tr><td class="paramname">vertices</td><td>Array of vertices in model space. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2543a39299d841a368ca5365d90a06c0" name="a2543a39299d841a368ca5365d90a06c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2543a39299d841a368ca5365d90a06c0">&#9670;&#160;</a></span>drawWireFrameQuad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe quad [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The lines are drawn with the current material color.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled. <br  />
</li>
<li>The four vertices of the quads must be co-planar.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3,P4</td><td>the quad vertices in model space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb256562836cddea025867ce83e836e5" name="abb256562836cddea025867ce83e836e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb256562836cddea025867ce83e836e5">&#9670;&#160;</a></span>drawWireFrameQuad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe quad [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled.</li>
<li>The four vertices of the quads must be co-planar.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1,P2,P3,P4</td><td>the quad vertices in model space. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bb11a254d95e6bcd239026f61cc83dc" name="a3bb11a254d95e6bcd239026f61cc83dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb11a254d95e6bcd239026f61cc83dc">&#9670;&#160;</a></span>drawWireFrameQuads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of wireframe quads [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The lines are drawn with the current material color.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled.</li>
<li>The four vertices of the quads must be co-planar.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_quads</td><td>number of quads to draw. </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>Array of vertex indexes. The length of the array is <code>nb_quads*4</code> and each 4 consecutive values represent a quad. </td></tr>
    <tr><td class="paramname">vertices</td><td>Array of vertices in model space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a845bbd628cfd96f379f3f23d880aa60a" name="a845bbd628cfd96f379f3f23d880aa60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845bbd628cfd96f379f3f23d880aa60a">&#9670;&#160;</a></span>drawWireFrameQuads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a collection of wireframe quads [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>This method does not use the z-buffer but backface culling is used if enabled.</li>
<li>The four vertices of the quads must be co-planar.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_quads</td><td>number of quads to draw. </td></tr>
    <tr><td class="paramname">ind_vertices</td><td>Array of vertex indexes. The length of the array is <code>nb_quads*4</code> and each 4 consecutive values represent a quad. </td></tr>
    <tr><td class="paramname">vertices</td><td>Array of vertices in model space. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1522a8010525348deefbfe92b8a9fe53" name="a1522a8010525348deefbfe92b8a9fe53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1522a8010525348deefbfe92b8a9fe53">&#9670;&#160;</a></span>drawWireFrameCube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameCube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw the wireframe cube [0,1]^3 (in model space) [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The model transform matrix may be used to scale, rotate and position the cube anywhere in world space. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afcbdcd49776f2d634a45138c3e8d4f82" name="afcbdcd49776f2d634a45138c3e8d4f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbdcd49776f2d634a45138c3e8d4f82">&#9670;&#160;</a></span>drawWireFrameCube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameCube </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw the wireframe cube [0,1]^3 (in model space) [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>The model transform matrix may be used to scale, rotate and position the cube anywhere in world space. <br  />
</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaeadf985edca06331aabd301d45a4ad" name="afaeadf985edca06331aabd301d45a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaeadf985edca06331aabd301d45a4ad">&#9670;&#160;</a></span>drawWireFrameSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Create a UV-sphere with a given number of sector and stacks.</li>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_sectors</td><td>number of sectors in the UV sphere. </td></tr>
    <tr><td class="paramname">nb_stacks</td><td>number of stacks in the UV sphere. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a497e0c79f349463357371f8502b6b9be" name="a497e0c79f349463357371f8502b6b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497e0c79f349463357371f8502b6b9be">&#9670;&#160;</a></span>drawWireFrameSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Create a UV-sphere with a given number of sector and stacks.</li>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_sectors</td><td>number of sectors in the UV sphere. </td></tr>
    <tr><td class="paramname">nb_stacks</td><td>number of stacks in the UV sphere. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43cd871e326daaeb9e26a85ec7bf2de6" name="a43cd871e326daaeb9e26a85ec7bf2de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cd871e326daaeb9e26a85ec7bf2de6">&#9670;&#160;</a></span>drawWireFrameAdaptativeSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em> = <code>1.0f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>low quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This method use (fast) low quality drawing: no thickness, no blending, no anti-aliasing.</li>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
<li>The mesh created is a UV-sphere and the number of sector and stacks is adjusted automatically according to the apparent size on the screen.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quality</td><td>Quality of the mesh. Should be positive, typically between 0.5f and 2.0f.<ul>
<li><code>1</code> : default quality</li>
<li><code>&gt;1</code>: finer mesh. Improve quality but decrease speed.</li>
<li><code>&lt;1</code>: coarser mesh. Decrease quality but improve speed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07e14dda511fab4edf94bc63096379c3" name="a07e14dda511fab4edf94bc63096379c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e14dda511fab4edf94bc63096379c3">&#9670;&#160;</a></span>drawWireFrameAdaptativeSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space) [<em>high quality</em>]. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>The model transform matrix may be used position the sphere anywhere in world space and change it to an ellipsoid.</li>
<li>This method use high quality drawing: blending with opacity, thickness, and anti-aliasing.</li>
<li>The mesh created is a UV-sphere and the number of sector and stacks is adjusted automatically according to the apparent size on the screen.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is very slow (may be slower that solid drawing) !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quality</td><td>Quality of the mesh. Should be positive, typically between 0.5f and 2.0f.<ul>
<li><code>1</code> : default quality</li>
<li><code>&gt;1</code>: finer mesh. Improve quality but decrease speed.</li>
<li><code>&lt;1</code>: coarser mesh. Decrease quality but improve speed. </li>
</ul>
</td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the lines </td></tr>
    <tr><td class="paramname">color</td><td>color to use </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in [0.0f, 1.0f] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bf2c28c514af367fd47964577f1584d" name="a8bf2c28c514af367fd47964577f1584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf2c28c514af367fd47964577f1584d">&#9670;&#160;</a></span>drawPixel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single pixel at a given position in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use the material color.</li>
<li>The scene lightning is ignored. <br  />
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position (in model space). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c7b04bab823ad980ae1680895f4ef66" name="a9c7b04bab823ad980ae1680895f4ef66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7b04bab823ad980ae1680895f4ef66">&#9670;&#160;</a></span>drawPixel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single pixel at a given position in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use blending with a given color and opacity factor.</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position (in model space). </td></tr>
    <tr><td class="paramname">color</td><td>color to use. </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity multiplier in <code>[0.0f, 1.0f]</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c10061203e26574e147aef75dcd2969" name="a9c10061203e26574e147aef75dcd2969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c10061203e26574e147aef75dcd2969">&#9670;&#160;</a></span>drawPixels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a list of pixels at given positions in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use the material color for all pixels.</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_pixels</td><td>number of pixels to draw. </td></tr>
    <tr><td class="paramname">pos_list</td><td>array of positions (in model space). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3cc940d37989db78a9cdaf790000fb6" name="af3cc940d37989db78a9cdaf790000fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cc940d37989db78a9cdaf790000fb6">&#9670;&#160;</a></span>drawPixels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>colors_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const color_t *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>opacities_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>opacities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a list of pixels at given positions in model space with different colors and opacities. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use blending with given colors and opacities given by a palette and a list of indices.</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_pixels</td><td>number of pixels to draw. </td></tr>
    <tr><td class="paramname">pos_list</td><td>array of positions (in model space). </td></tr>
    <tr><td class="paramname">colors_ind</td><td>array of color indices. </td></tr>
    <tr><td class="paramname">colors</td><td>array of colors. </td></tr>
    <tr><td class="paramname">opacities_ind</td><td>array of opacities indices. </td></tr>
    <tr><td class="paramname">opacities</td><td>array of opacities </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae965bedf9a2eb21f8a5cc7c2f389f367" name="ae965bedf9a2eb21f8a5cc7c2f389f367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae965bedf9a2eb21f8a5cc7c2f389f367">&#9670;&#160;</a></span>drawDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a dot/circle at a given position in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use the the material color.</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position in model space. </td></tr>
    <tr><td class="paramname">r</td><td>radius in pixels (integer valued). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0459fa6b84613036c70e17fd7d944d49" name="a0459fa6b84613036c70e17fd7d944d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0459fa6b84613036c70e17fd7d944d49">&#9670;&#160;</a></span>drawDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a dot/circle at a given position in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use blending with the given color and opacity. <br  />
</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position in model space. </td></tr>
    <tr><td class="paramname">r</td><td>radius in pixels. </td></tr>
    <tr><td class="paramname">color</td><td>color to use. </td></tr>
    <tr><td class="paramname">opacity</td><td>The opacity for blending in [0.0f, 1.0f]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a616b7d7ad47a01a821532719998c3fda" name="a616b7d7ad47a01a821532719998c3fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616b7d7ad47a01a821532719998c3fda">&#9670;&#160;</a></span>drawDots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a list of dots/circles at given positions in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use the material color and the same radius for every dot.</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_dots</td><td>number of dots to draw </td></tr>
    <tr><td class="paramname">pos_list</td><td>array of positions in model space. </td></tr>
    <tr><td class="paramname">radius</td><td>radius in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ddcca2d8bb674777bff0ba74e314b2" name="a31ddcca2d8bb674777bff0ba74e314b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ddcca2d8bb674777bff0ba74e314b2">&#9670;&#160;</a></span>drawDots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , <a class="el" href="_shader_params_8h.html#ab84545b1975d51484ba2f5970b858d07">Shader</a> LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>colors_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const color_t *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>opacities_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>opacities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a list of dots/circles at given positions in model space. </p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Use a different radius and colors for every dot.</li>
<li>Use blending with given colors and opacities given by a palette and a list of indices.</li>
<li>The scene lightning is ignored.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_dots</td><td>number of dots to draw. </td></tr>
    <tr><td class="paramname">pos_list</td><td>array of positions in model space. </td></tr>
    <tr><td class="paramname">radius_ind</td><td>array of radius indices. </td></tr>
    <tr><td class="paramname">radius</td><td>array of radiuses. </td></tr>
    <tr><td class="paramname">colors_ind</td><td>array of color indices. </td></tr>
    <tr><td class="paramname">colors</td><td>array of colors. </td></tr>
    <tr><td class="paramname">opacities_ind</td><td>array of opacity indices. </td></tr>
    <tr><td class="paramname">opacities</td><td>array of opacities value in [0.0f, 1.0f]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_renderer3_d_8h_source.html">Renderer3D.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>tgx</b></li><li class="navelem"><a class="el" href="classtgx_1_1_renderer3_d.html">Renderer3D</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
